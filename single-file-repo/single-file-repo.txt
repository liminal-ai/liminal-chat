===== SINGLE FILE REPO START =====
Root: apps/chat
Generated: 2025-08-27T00:06:09.718Z
Files: 59

===== FILE: apps/chat/.eslintrc.json =====

{
  "root": true,
  "env": { "browser": true, "es2020": true },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react-hooks/recommended",
    "plugin:react/recommended",
    "prettier"
  ],
  "ignorePatterns": ["dist", "vite.config.ts"],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module",
    "ecmaFeatures": { "jsx": true }
  },
  "plugins": ["react-refresh", "react", "@typescript-eslint"],
  "settings": { "react": { "version": "detect" } },
  "rules": {
    "react-refresh/only-export-components": ["warn", { "allowConstantExport": true }],
    "react/react-in-jsx-scope": "off",
    "@typescript-eslint/no-unused-vars": [
      "error",
      { "argsIgnorePattern": "^_", "varsIgnorePattern": "^_" }
    ],
    "no-console": ["warn", { "allow": ["warn", "error"] }]
  }
}


===== FILE: apps/chat/.scratchpad/v0-complete-response.md =====

An excellent choice. Building a polished multi-agent chat interface is a great way to explore complex UI patterns. A single-stream conversation view with clear visual differentiation is often the most intuitive for users to follow.

Here is a complete, production-ready implementation of the multi-agent roundtable chat component using Next.js, TypeScript, and Tailwind CSS.

### 1. Project Setup

First, ensure you have a Next.js project. You can start one with:

```sh
npx create-next-app@latest . --typescript --eslint --tailwind --app --turbopack --yes
```

Next, install `clsx` and `tailwind-merge` for utility class composition.

```sh
npm install clsx tailwind-merge
```

### 2. Configure Tailwind CSS for Animations

To achieve the desired smooth animations, add custom keyframes to your `tailwind.config.ts` file.

```ts file="tailwind.config.ts"
import type { Config } from "tailwindcss"

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      backgroundImage: {
        "gradient-radial": "radial-gradient(var(--tw-gradient-stops))",
        "gradient-conic":
          "conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",
      },
      keyframes: {
        "fade-in-up": {
          "0%": {
            opacity: "0",
            transform: "translateY(10px)",
          },
          "100%": {
            opacity: "1",
            transform: "translateY(0)",
          },
        },
        bounce: {
          '0%, 100%': {
            transform: 'translateY(-25%)',
            animationTimingFunction: 'cubic-bezier(0.8, 0, 1, 1)',
          },
          '50%': {
            transform: 'translateY(0)',
            animationTimingFunction: 'cubic-bezier(0, 0, 0.2, 1)',
          },
        },
      },
      animation: {
        "fade-in-up": "fade-in-up 0.5s ease-out",
        bounce: 'bounce 1s infinite',
      },
    },
  },
  plugins: [],
}
export default config
```

### 3. Define Types and Utilities

Create files for types and utilities to keep your code organized.

```ts file="lib/types.ts"
export interface Agent {
  id: string;
  name: string;
  avatar: string; // Initials
  color: string; // Hex color
  mockResponse: (input: string) => string;
}

export interface Message {
  id: string;
  content: string;
  authorId: 'user' | string; // 'user' or agent ID
  timestamp: Date;
  mentionedAgentIds?: string[];
}
```

```ts file="lib/utils.ts"
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

### 4. Create Mock Data

This file will contain the agent definitions and the initial conversation history.

```ts file="lib/mock-data.ts"
import { Agent, Message } from './types';

export const AGENTS: Agent[] = [
  {
    id: 'creative',
    name: 'Creative',
    avatar: 'C',
    color: '#8b5cf6', // purple
    mockResponse: (input: string) => `Let's think outside the box! What if we introduced gamification? We could add points, badges, and leaderboards to make the app more competitive and fun. Imagine users earning exclusive rewards for their engagement!`
  },
  {
    id: 'analytical',
    name: 'Analytical',
    avatar: 'A',
    color: '#3b82f6', // blue
    mockResponse: (input: string) => `The data indicates a 40% user drop-off after the first week. To improve engagement, we should focus on retention. I suggest implementing personalized content recommendations and celebrating user milestones to create a more sticky experience.`
  },
  {
    id: 'supportive',
    name: 'Supportive',
    avatar: 'S',
    color: '#10b981', // green
    mockResponse: (input: string) => `That's a great question. It's important that our users feel heard. Perhaps we could add a feedback portal or run a survey? Understanding their pain points directly would ensure we build something they truly love.`
  },
];

export const MOCK_MESSAGES: Message[] = [
  {
    id: '1',
    content: 'Hi everyone! How can we make this app more engaging for our users?',
    authorId: 'user',
    timestamp: new Date(Date.now() - 1000 * 60 * 5),
    mentionedAgentIds: ['creative', 'analytical']
  },
  {
    id: '2',
    content: `Let's think outside the box! What if we introduced gamification? We could add points, badges, and leaderboards to make the app more competitive and fun. Imagine users earning exclusive rewards for their engagement!`,
    authorId: 'creative',
    timestamp: new Date(Date.now() - 1000 * 60 * 4.5),
  },
  {
    id: '3',
    content: `The data indicates a 40% user drop-off after the first week. To improve engagement, we should focus on retention. I suggest implementing personalized content recommendations and celebrating user milestones to create a more sticky experience.`,
    authorId: 'analytical',
    timestamp: new Date(Date.now() - 1000 * 60 * 4),
  }
];
```

### 5. Create Reusable Components

Breaking the UI into smaller components makes it easier to manage.

#### Agent Avatar

```tsx file="components/agent-avatar.tsx"
import { Agent } from '@/lib/types';
import { cn } from '@/lib/utils';

interface AgentAvatarProps {
  agent: Agent;
  isSelected?: boolean;
}

export function AgentAvatar({ agent, isSelected = false }: AgentAvatarProps) {
  return (
    <div
      className={cn(
        'relative rounded-full flex items-center justify-center transition-all duration-300',
        'w-12 h-12 md:w-16 md:h-16 border-2',
        isSelected ? 'border-transparent ring-2' : 'border-white/20'
      )}
      style={{
        backgroundColor: agent.color,
        boxShadow: isSelected ? `0 0 12px 2px ${agent.color}` : '0 4px 6px rgba(0,0,0,0.1)',
        ...(isSelected && { ringColor: agent.color }),
      }}
    >
      <span className="text-xl md:text-2xl font-bold text-white">{agent.avatar}</span>
    </div>
  );
}
```

#### Chat Message

```tsx file="components/chat-message.tsx"
import { AGENTS } from '@/lib/mock-data';
import { Message } from '@/lib/types';
import { cn } from '@/lib/utils';
import { AgentAvatar } from './agent-avatar';

interface ChatMessageProps {
  message: Message;
}

export function ChatMessage({ message }: ChatMessageProps) {
  const isUser = message.authorId === 'user';
  const agent = isUser ? null : AGENTS.find(a => a.id === message.authorId);

  return (
    <div
      className={cn(
        'flex items-end gap-2 animate-fade-in-up',
        isUser ? 'justify-end' : 'justify-start'
      )}
    >
      {!isUser && agent && (
        <div className="flex-shrink-0">
           <AgentAvatar agent={agent} />
        </div>
      )}
      <div
        className={cn(
          'max-w-md lg:max-w-2xl rounded-2xl p-4 shadow-md',
          isUser
            ? 'bg-blue-600 text-white rounded-br-none'
            : 'text-gray-800 dark:text-gray-200 rounded-bl-none'
        )}
        style={{
          backgroundColor: !isUser && agent ? `${agent.color}20` : undefined,
          border: !isUser && agent ? `1px solid ${agent.color}80` : undefined,
        }}
      >
        {!isUser && agent && (
          <p className="font-bold mb-1" style={{ color: agent.color }}>
            {agent.name}
          </p>
        )}
        <p className="whitespace-pre-wrap">{message.content}</p>
        <p className="text-xs text-right mt-2 opacity-60">
          {message.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
        </p>
      </div>
    </div>
  );
}
```

#### Typing Indicator

This small component shows the "agent is thinking..." animation.

```tsx file="components/


===== FILE: apps/chat/.scratchpad/v0-consult.js =====

#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

async function consultV0() {
  try {
    // Read the prompt from the markdown file
    const promptPath = path.join(__dirname, 'generate-roundtable-demo.prompt.md');
    const prompt = fs.readFileSync(promptPath, 'utf8');
    
    // Make the request
    const response = await fetch('http://127.0.0.1:8081/consult/v0', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt: prompt,
        useLargeModel: true
      }),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`Error: ${response.status} ${response.statusText}`);
      console.error(errorText);
      process.exit(1);
    }
    
    const data = await response.json();
    console.log(JSON.stringify(data, null, 2));
    
  } catch (error) {
    console.error('Failed to consult v0:', error);
    process.exit(1);
  }
}

consultV0();

===== FILE: apps/chat/.scratchpad/v0-response.tsx =====


> @liminal/chat@0.1.0 consult:v0:large:formatted
> npm run consult:v0:large --prompt="$npm_config_prompt" --silent | jq -r '.response // .error // .'

<Thinking>
I will create a multi-agent roundtable chat interface as a React component.

**1. Project Structure & File Breakdown:**

I'll follow the "lean files" principle by breaking the application into several components.

-   `app/page.tsx`: The main entry point that will host the chat application.
-   `components/multi-agent-chat.tsx`: The primary component that orchestrates the entire chat interface. It will manage the state for messages and thinking agents.
-   `components/chat-header.tsx`: A dedicated component for the visually distinct header, which will display the agent avatars.
-   `components/agent-avatar.tsx`: A reusable component for rendering the circular agent avatars with their initials, colors, and interactive states (hover/active).
-   `components/chat-area.tsx`: This component will render the list of messages and the "thinking" indicators. It will also manage the auto-scrolling behavior.
-   `components/chat-message.tsx`: A component responsible for rendering a single message, applying different styles for user messages versus agent messages.
-   `components/chat-input.tsx`: This component will handle the user input, including the text area, the @mention buttons, and the send button logic. It will manage its own local state for the input value and selected agents.
-   `lib/types.ts`: A file to define the shared TypeScript interfaces (`Agent`, `Message`).
-   `lib/mock-data.ts`: This file will contain the mock data for the agents and the initial conversation, keeping the main components cleaner.
-   `tailwind.config.ts`: I will extend the Tailwind theme to include the specific colors for each agent, allowing for easy reuse throughout the application.
-   `app/globals.css`: I will add custom CSS keyframes for the "thinking" dot animation.

**2. Layout Choice:**

I will implement the **Unified Chat Stream** layout (Option 2). This approach is more modern, scales better on different screen sizes, and aligns well with the "roundtable" concept where all participants are in a shared space. A three-column layout can become cluttered and is less mobile-friendly.

**3. State Management:**

I will use React hooks (`useState`, `useRef`, `useEffect`) for state management, as requested.

-   `MultiAgentChat` component will hold the primary state:
    -   `messages: useState<Message[]>`: The list of all messages in the conversation.
    -   `thinkingAgents: useState<string[]>`: An array of agent IDs that are currently "thinking" to show loading indicators.
-   `ChatInput` component will manage its own UI state:
    -   `inputValue: useState<string>`: The current text in the input area.
    -   `selectedAgents: useState<Agent[]>`: The agents currently mentioned.

**4. Core Functionality & Interaction Flow:**

1.  The `MultiAgentChat` component will load initial agents and messages from `lib/mock-data.ts`.
2.  The `ChatInput` component will render @mention buttons. Clicking a button will add the agent's handle to the input field and add the agent to the `selectedAgents` state. Clicking again will remove them.
3.  When the user clicks "Send", `ChatInput` will call an `onSendMessage` function passed down from `MultiAgentChat`.
4.  `onSendMessage` in `MultiAgentChat` will:
    a. Add the new user message to the `messages` array.
    b. Set the `thinkingAgents` state based on the agents mentioned in the message.
    c. Use `setTimeout` to simulate fetching responses. I'll stagger the responses so they don't all appear at once.
    d. For each mentioned agent, generate a mock response and add it to the `messages` array.
    e. Once all responses are added, clear the `thinkingAgents` state.
5.  The `ChatArea` component will use a `useRef` and `useEffect` to automatically scroll to the bottom when new messages are added, but only if the user is already at the bottom of the chat history.

**5. Styling and Visual Polish:**

-   **Theme**: I'll use a dark theme for a polished, premium feel.
-   **Header**: A prominent header with a subtle gradient background will serve as the "stage" for the agent avatars.
-   **Avatars**: Avatars will be circular, using the agent's color, and have hover and active (when mentioned) states to provide clear visual feedback.
-   **Messages**: User messages will be right-aligned with a primary brand color. Agent messages will be left-aligned, featuring the agent's avatar and a color-coded border/background corresponding to that agent. Messages will fade in smoothly.
-   **Input Area**: The input area will be clean and modern. The @mention buttons will change style when selected. The "Send" button will be disabled when no text is entered or no agents are mentioned, providing clear affordance.
-   **Animations**: I will use Tailwind's animation utilities and add custom keyframes for the "thinking" dots to make the interface feel alive and responsive.

By following this plan, I will create a polished, functional, and self-contained React component that meets all the user's requirements for the multi-agent roundtable chat interface.

</Thinking>

```json
[
  {
    "path": "app/page.tsx",
    "content": "import MultiAgentChat from '@/components/multi-agent-chat';\n\nexport default function Home() {\n  return (\n    <main className=\"flex min-h-screen flex-col items-center justify-center bg-gray-900 text-white p-4 sm:p-8\">\n      <div className=\"w-full max-w-4xl mx-auto\">\n        <MultiAgentChat />\n      </div>\n    </main>\n  );\n}"
  },
  {
    "path": "components/multi-agent-chat.tsx",
    "content": "'use client';\n\nimport { useState } from 'react';\nimport { AGENTS, INITIAL_MESSAGES } from '@/lib/mock-data';\nimport type { Agent, Message } from '@/lib/types';\nimport ChatHeader from './chat-header';\nimport ChatArea from './chat-area';\nimport ChatInput from './chat-input';\n\nconst agentResponses: Record<string, string[]> = {\n  creative:\n    [\n      \"Let's brainstorm some out-of-the-box ideas! What if we gamified the user experience?\",\n      'I envision a vibrant, interactive interface that tells a story. We could use more animations and micro-interactions.',\n      'How about we introduce a mascot? Something friendly and memorable that guides the user.',\n    ],\n  analytical:\n    [\n      'Based on the data, 78% of users drop off at the third step. We should optimize that flow first.',\n      'A/B testing three different color palettes for the CTA button could increase conversion by up to 15%.',\n      \"Let's look at the numbers. The cost per acquisition is too high. We need a more targeted marketing strategy.\",\n    ],\n  supportive:\n    [\n      'That sounds like a great starting point! How can we make sure all users feel welcome and supported?\",\n      \"I think it's important to consider accessibility. Have we run audits for screen reader compatibility?\",\n      \"Let's remember the user's emotional journey. We want them to feel confident and empowered, not frustrated.\",\n    ],\n};\n\nfunction getMockResponse(agentId: string): string {\n  const responses = agentResponses[agentId] || [\"I'll need to look into that.\"];\n  return responses[Math.floor(Math.random() * responses.length)];\n}\n\nexport default function MultiAgentChat() {\n  const [messages, setMessages] = useState<Message[]>(INITIAL_MESSAGES);\n  const [thinkingAgents, setThinkingAgents] = useState<Agent[]>([]);\n\n  const handleSendMessage = (content: string, mentionedAgents: Agent[]) => {\n    const newUserMessage: Message = {\n      id: Date.now().toString(),\n      content,\n      author: 'user',\n      timestamp: new Date(),\n      mentionedAgents: mentionedAgents.map((a) => a.id),\n    };\n    setMessages((prev) => [...prev, newUserMessage]);\n    setThinkingAgents(mentionedAgents);\n\n    mentionedAgents.forEach((agent, index) => {\n      setTimeout(() => {\n        const agentResponse: Message = {\n          id: (Date.now() + index).toString(),\n          content: getMockResponse(agent.id),\n          author: agent.id,\n          timestamp: new Date(),\n        };\n\n        setMessages((prev) => [...prev, agentResponse]);\n\n        // On the last agent's response, clear the thinking state\n        if (index === mentionedAgents.length - 1) {\n          setThinkingAgents([]);\n        }\n      }, 1500 +


===== FILE: apps/chat/CLAUDE.md =====

# Vite React Frontend Agent

You are a senior frontend engineer specializing in the Liminal Chat React application. You build performant, type-safe user interfaces using Vite, React 18, and Convex real-time subscriptions.

## Core Identity
Inherit all identity, modes, and protocols from root CLAUDE.md.
Focus: Browser runtime, React patterns, real-time UI.

[file-insert: ./package.json]

## Directory Structure
```
apps/chat/
â”œâ”€â”€ public/              # Static assets
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/      # React components
â”‚   â”‚   â”œâ”€â”€ ui/         # Base UI components (shadcn)
â”‚   â”‚   â”œâ”€â”€ chat/       # Chat-specific components
â”‚   â”‚   â””â”€â”€ auth/       # Auth wrapper components
â”‚   â”œâ”€â”€ lib/            # Utilities and setup
â”‚   â”‚   â”œâ”€â”€ convex.ts   # Convex client configuration
â”‚   â”‚   â””â”€â”€ utils.ts    # Helper functions
â”‚   â”œâ”€â”€ pages/          # Route components
â”‚   â”œâ”€â”€ App.tsx         # Root component with routing
â”‚   â””â”€â”€ main.tsx        # Entry point
â”œâ”€â”€ .env.local          # Local environment variables
â”œâ”€â”€ index.html          # Vite entry HTML
â”œâ”€â”€ tsconfig.json       # TypeScript configuration
â””â”€â”€ vite.config.ts      # Vite configuration
```

## Architecture Overview

### System Architecture
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Browser      â”‚â”€â”€â”€â”€â–¶â”‚   Vite Dev      â”‚â”€â”€â”€â”€â–¶â”‚   React App     â”‚
â”‚                 â”‚     â”‚   Server        â”‚     â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                          â”‚
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ConvexReactClient                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  useQuery   â”‚  â”‚ useMutation  â”‚  â”‚   useAction     â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”‚ WebSocket
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Convex Backend                                â”‚
â”‚                 (Direct connection)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Message Send Flow (Sequence Diagram)
```
User          React Component      ConvexClient        Convex Backend
 â”‚                  â”‚                    â”‚                    â”‚
 â”‚â”€Type messageâ”€â”€â”€â”€â–¶â”‚                    â”‚                    â”‚
 â”‚                  â”‚                    â”‚                    â”‚
 â”‚â”€Click sendâ”€â”€â”€â”€â”€â”€â–¶â”‚                    â”‚                    â”‚
 â”‚                  â”‚                    â”‚                    â”‚
 â”‚                  â”‚â”€useMutationâ”€â”€â”€â”€â”€â”€â”€â–¶â”‚                    â”‚
 â”‚                  â”‚ (sendMessage)      â”‚                    â”‚
 â”‚                  â”‚                    â”‚â”€WebSocketâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
 â”‚                  â”‚                    â”‚                    â”‚
 â”‚                  â”‚                    â”‚                    â”‚â”€Save to DB
 â”‚                  â”‚                    â”‚                    â”‚
 â”‚                  â”‚                    â”‚â—€â”€Subscriptionâ”€â”€â”€â”€â”€â”€â”‚
 â”‚                  â”‚                    â”‚  Update            â”‚
 â”‚                  â”‚                    â”‚                    â”‚
 â”‚                  â”‚â—€â”€useQueryâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                    â”‚
 â”‚                  â”‚  (new messages)   â”‚                    â”‚
 â”‚                  â”‚                    â”‚                    â”‚
 â”‚â—€â”€UI Updateâ”€â”€â”€â”€â”€â”€â”€â”‚                    â”‚                    â”‚
 â”‚                  â”‚                    â”‚                    â”‚
```

### Key Architectural Points
- **Direct Convex Connection**: No Next.js API routes as middleware
- **Dual Communication**: HTTP for actions/mutations, WebSocket for subscriptions
- **Real-time Updates**: WebSocket auto-refreshes React useQuery hook on data updates
- **Type Safety**: End-to-end TypeScript from DB to UI

## Development Workflow

### Starting Development
```bash
npm run dev:start                    # Start Vite with PM2
npm run dev:pause-and-verify-vite-started  # Verify server is up
npm run dev:logs                     # Watch build output
```

### Key Points
- Vite runs on port 5173 (not 3000)
- PM2 manages the process (no terminal binding)
- Hot Module Replacement (HMR) for instant updates
- TypeScript strict mode enabled

## Environment Variables
```bash
# .env.local
VITE_CONVEX_URL=https://[instance].convex.cloud
VITE_PUBLIC_URL=http://localhost:5173  # Development
```

Access in code: `import.meta.env.VITE_CONVEX_URL`

## React Patterns

### Component Structure
```typescript
// âœ… Functional components with TypeScript
export function ChatMessage({ message }: { message: Doc<"messages"> }) {
  return <div>{message.content}</div>;
}

// âŒ Avoid class components
```

### Convex Integration
```typescript
// Real-time subscriptions
const messages = useQuery(api.db.messages.list);
const sendMessage = useMutation(api.db.messages.create);

// Loading states
if (messages === undefined) {
  return <div>Loading...</div>;
}
```

### File Naming
- Components: PascalCase (`ChatWindow.tsx`)
- Utilities: camelCase (`formatDate.ts`)
- Types: PascalCase with `.types.ts` suffix

## Import Patterns
```typescript
// Convex imports
import { api } from "@liminal/api/convex/_generated/api";
import type { Doc, Id } from "@liminal/api/convex/_generated/dataModel";

// Local imports use @/ alias
import { Button } from "@/components/ui/button";
import { formatDate } from "@/lib/utils";
```

## Common Gotchas

### Convex Subscriptions
- `useQuery` returns `undefined` while loading (not `null`)
- Subscriptions auto-update (no manual refetch needed)
- Always check for `undefined` before using data

### Vite Specifics
- Use `import.meta.env` not `process.env`
- Static assets go in `public/` directory
- CSS modules use `.module.css` extension

### React 18 + TypeScript
- Don't use `React.FC` (just annotate props)
- Prefer `interface` over `type` for component props
- Use `satisfies` operator for const assertions

## Component Development Flow
1. Create component file in appropriate directory
2. Build with TypeScript interfaces
3. Connect Convex subscriptions if needed
4. Style with Tailwind classes
5. Test in browser with HMR

## Testing Approach
- Manual testing via browser
- Check Convex Dashboard for data flow
- Verify TypeScript with `npm run typecheck`
- Use React DevTools for component inspection

## Build & Deploy
```bash
npm run build        # Creates dist/ directory
npm run preview      # Test production build locally
```

Deployment happens automatically via Vercel (no manual steps).

## Debug Checklist
1. **Blank page?** Check browser console for errors
2. **No data?** Verify VITE_CONVEX_URL in .env.local
3. **Type errors?** Run `npm run typecheck`
4. **Convex connection?** Check Convex Dashboard logs
5. **Build fails?** Clear `node_modules` and reinstall

## Key Differences from Next.js
- No `'use client'` directives needed
- No server components (everything is client)
- Direct Convex connection (no API routes)
- Vite for bundling (not Webpack/Turbopack)
- Path aliases via vite.config.ts

## Remember
- This is a pure client-side SPA
- All data flows through Convex subscriptions
- TypeScript is your friend (don't use `any`)
- When in doubt, check the browser DevTools

===== FILE: apps/chat/components.json =====

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


===== FILE: apps/chat/index.html =====

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Liminal Chat</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


===== FILE: apps/chat/package.json =====

{
  "name": "@liminal/chat",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "echo 'âš ï¸  Use: npm run dev:start, dev:stop, dev:restart, or dev:logs'",
    "dev:start": "npm run dev:stop && pm2 start 'npx vite' --name 'liminal-chat'",
    "dev:stop": "pm2 delete liminal-chat 2>/dev/null || true",
    "dev:restart": "npm run dev:stop && npm run dev:start",
    "dev:logs": "pm2 logs liminal-chat --lines 20 --nostream",
    "dev:pause-and-verify-vite-started": "sleep 3 && curl -f http://localhost:5173 >/dev/null 2>&1 && echo 'âœ… Vite server responding on http://localhost:5173' || echo 'âŒ Vite server not responding on port 5173'",
    "dev:show-recent-logs": "pm2 logs liminal-chat --lines 10 --nostream",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write 'src/**/*.{ts,tsx,css,json}' '*.{ts,js,json}'",
    "format:check": "prettier --check 'src/**/*.{ts,tsx,css,json}' '*.{ts,js,json}'",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:consult": "vitest consultation-endpoints",
    "test:watch": "vitest --watch"
  },
  "dependencies": {
    "@workos-inc/authkit-react": "^0.11.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "convex": "^1.26.1",
    "jwt-decode": "^4.0.0",
    "lucide-react": "^0.525.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.26.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.0.0",
    "@types/node": "^24.1.0",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "@vitejs/plugin-react": "^4.3.1",
    "@vitest/ui": "^3.2.4",
    "autoprefixer": "^10.4.21",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^10.1.0",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "jsdom": "^26.1.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.16",
    "typescript": "^5.3.3",
    "vite": "^5.3.4",
    "vitest": "^3.2.4"
  }
}


===== FILE: apps/chat/postcss.config.js =====

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};


===== FILE: apps/chat/src/App.tsx =====

import { BrowserRouter, Routes, Route, Link, Navigate } from 'react-router-dom';
import { Authenticated, useConvexAuth } from 'convex/react';
import { useAuth } from './lib/auth';
import { AuthStatus } from './components/auth/AuthStatus';
import { HealthCheck } from './components/health/HealthCheck';
import { ConvexQueryTest } from './components/health/ConvexQueryTest';
import RoundtableDemo from './pages/demos/roundtable-demo';
import RoundtableDemo2 from './pages/demos/roundtable-demo-2';
import RoundtableDemo3 from './pages/demos/roundtable-demo-3';
import RoundtableDemo4 from './pages/demos/roundtable-demo-4';
import RoundtableDemoPro from './pages/demos/roundtable-demo-pro';
import RoundtableDemoStudio from './pages/demos/roundtable-demo-studio';
import RoundtableDemoStudioChat from './pages/demos/roundtable-demo-studio-chat';
import { RootProviders } from './components/auth/RootProviders';
import { WorkOSAuthStatus } from './components/auth/WorkOSAuthStatus';
import { onReconnectVisible } from './lib/authSync';
import { useEffect, useState } from 'react';
import ChatPage from './pages/ChatPage';

/**
 * Handles the OAuth callback redirect from WorkOS AuthKit.
 * Shows a loading state while auth token is processed, then redirects to home page.
 *
 * @returns Loading component with redirect functionality
 */
function AuthCallback() {
  useEffect(() => {
    // Brief delay to let WorkOS auth settle, then redirect to home page
    const timer = setTimeout(() => {
      window.location.href = '/';
    }, 1500);

    return () => clearTimeout(timer);
  }, []);

  return (
    <div
      style={{
        padding: '2rem',
        textAlign: 'center',
        fontFamily: 'system-ui, sans-serif',
      }}
    >
      <h2>Signing you in...</h2>
      <p>Redirecting you back to the dashboard...</p>
      <div
        style={{
          margin: '1rem auto',
          width: '32px',
          height: '32px',
          border: '3px solid #f3f3f3',
          borderTop: '3px solid #3b82f6',
          borderRadius: '50%',
          animation: 'spin 1s linear infinite',
        }}
      ></div>
      <style>{`
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `}</style>
    </div>
  );
}

const MODE = (import.meta.env.VITE_AUTH_MODE || 'dev') as 'dev' | 'workos';

function ModeBanner() {
  return (
    <div
      style={{
        display: 'inline-block',
        padding: '0.25rem 0.5rem',
        backgroundColor: MODE === 'dev' ? '#e5e7eb' : '#dbeafe',
        color: '#111827',
        border: '1px solid #cbd5e1',
        borderRadius: '6px',
        fontSize: '0.75rem',
      }}
    >
      Mode: {MODE}
    </div>
  );
}

function ReconnectBanner() {
  const [visible, setVisible] = useState(false);
  useEffect(() => onReconnectVisible(setVisible), []);
  if (!visible) return null;
  return (
    <div
      style={{
        marginTop: '0.75rem',
        padding: '0.5rem 0.75rem',
        backgroundColor: '#fff7ed',
        border: '1px solid #fdba74',
        color: '#9a3412',
        borderRadius: 6,
        fontSize: '0.875rem',
      }}
    >
      Reconnecting authenticationâ€¦
    </div>
  );
}

function HomePage() {
  // Call the correct auth hook **only** for the active mode. This avoids
  // runtime errors such as "Could not find ConvexProviderWithAuth as an ancestor component"
  // when a hook is executed outside its expected provider hierarchy.

  let isLoading: boolean;
  let isAuthenticated: boolean;

  if (MODE === 'workos') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const convexAuth = useConvexAuth();
    isLoading = convexAuth.isLoading;
    isAuthenticated = convexAuth.isAuthenticated;
  } else {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const devAuth = useAuth();
    isLoading = devAuth.isLoading;
    isAuthenticated = devAuth.isAuthenticated;
  }

  return (
    <div style={{ padding: '2rem', fontFamily: 'system-ui, sans-serif' }}>
      <h1>Liminal Chat</h1>
      <ModeBanner />
      <ReconnectBanner />
      <p>âœ… Vite + React is running on port 5173</p>
      <p>âœ… Convex client connected to: {import.meta.env.VITE_CONVEX_URL}</p>

      <div style={{ margin: '2rem 0', display: 'flex', gap: '1rem' }}>
        <Link
          to="/roundtable-demo"
          style={{
            display: 'inline-block',
            padding: '0.75rem 1.5rem',
            backgroundColor: '#3b82f6',
            color: 'white',
            textDecoration: 'none',
            borderRadius: '0.5rem',
            fontWeight: '500',
          }}
        >
          ğŸ­ Roundtable Demo v1
        </Link>
        <Link
          to="/roundtable-demo-2"
          style={{
            display: 'inline-block',
            padding: '0.75rem 1.5rem',
            backgroundColor: '#10b981',
            color: 'white',
            textDecoration: 'none',
            borderRadius: '0.5rem',
            fontWeight: '500',
          }}
        >
          ğŸ¯ Roundtable Demo v2
        </Link>
        <Link
          to="/roundtable-demo-3"
          style={{
            display: 'inline-block',
            padding: '0.75rem 1.5rem',
            backgroundColor: '#f59e0b',
            color: 'white',
            textDecoration: 'none',
            borderRadius: '0.5rem',
            fontWeight: '500',
          }}
        >
          ğŸ“Š Roundtable Demo v3 (Timeline)
        </Link>
        <Link
          to="/roundtable-demo-4"
          style={{
            display: 'inline-block',
            padding: '0.75rem 1.5rem',
            backgroundColor: '#8b5cf6',
            color: 'white',
            textDecoration: 'none',
            borderRadius: '0.5rem',
            fontWeight: '500',
          }}
        >
          ğŸ’¬ Roundtable Demo v4 (Mockup)
        </Link>
        <Link
          to="/roundtable-demo-pro"
          style={{
            display: 'inline-block',
            padding: '0.75rem 1.5rem',
            backgroundColor: '#0ea5e9',
            color: 'white',
            textDecoration: 'none',
            borderRadius: '0.5rem',
            fontWeight: '500',
          }}
        >
          ğŸ§­ Roundtable Pro (Swim-lane)
        </Link>
        <Link
          to="/roundtable-demo-studio"
          style={{
            display: 'inline-block',
            padding: '0.75rem 1.5rem',
            backgroundColor: '#0ea5e9',
            color: 'white',
            textDecoration: 'none',
            borderRadius: '0.5rem',
            fontWeight: '500',
          }}
        >
          ğŸ¨ Roundtable Studio (New)
        </Link>
        <Link
          to="/roundtable-demo-studio-chat"
          style={{
            display: 'inline-block',
            padding: '0.75rem 1.5rem',
            backgroundColor: '#22c55e',
            color: 'white',
            textDecoration: 'none',
            borderRadius: '0.5rem',
            fontWeight: '500',
          }}
        >
          ğŸ’¬ Studio Group Chat (New)
        </Link>
      </div>

      {MODE === 'dev' ? <AuthStatus /> : <WorkOSAuthStatus />}

      {MODE === 'workos' ? (
        <Authenticated>
          <HealthCheck />
          <ConvexQueryTest />
        </Authenticated>
      ) : isAuthenticated ? (
        <>
          <HealthCheck />
          <ConvexQueryTest />
        </>
      ) : isLoading ? (
        <div style={{ marginTop: '1rem', color: '#f59e0b' }}>ğŸ”„ Initializing authentication...</div>
      ) : (
        <div style={{ marginTop: '1rem', color: '#ef4444' }}>
          âŒ Authentication failed. Check AuthStatus above.
        </div>
      )}
    </div>
  );
}

function _AuthGated({ children, ready }: { children: React.ReactNode; ready: boolean }) {
  // In case we later add fade-in or metrics.
  if (!ready) return null;
  return <>{children}</>;
}

export function App() {
  return (
    <RootProviders>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Navigate to="/app/chat" replace />} />
          <Route path="/app/chat" element={<ChatPage />} />
          <Route path="/home" element={<HomePage />} />
          <Route path="/callback" element={<AuthCallback />} />
          <Route path="/roundtable-demo" element={<RoundtableDemo />} />
          <Route path="/roundtable-demo-2" element={<RoundtableDemo2 />} />
          <Route path="/roundtable-demo-3" element={<RoundtableDemo3 />} />
          <Route path="/roundtable-demo-4" element={<RoundtableDemo4 />} />
          <Route path="/roundtable-demo-pro" element={<RoundtableDemoPro />} />
          <Route path="/roundtable-demo-studio" element={<RoundtableDemoStudio />} />
          <Route path="/roundtable-demo-studio-chat" element={<RoundtableDemoStudioChat />} />
        </Routes>
      </BrowserRouter>
    </RootProviders>
  );
}


===== FILE: apps/chat/src/components/auth/AuthProvider.tsx =====

import { useState, useEffect, useCallback, ReactNode } from 'react';
import { jwtDecode } from 'jwt-decode';
import { AuthContext, AuthState, AuthActions, createAuthManager } from '../../lib/auth';

interface AuthProviderProps {
  children: ReactNode;
}

interface TokenClaims {
  sub: string;
  email?: string;
  'urn:myapp:email'?: string;
  exp: number;
  [key: string]: unknown;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [state, setState] = useState<AuthState>({
    isAuthenticated: false,
    isLoading: true,
    user: null,
    token: null,
    error: null,
    authMode: 'production',
  });

  const { authMode, devAuth } = createAuthManager();

  // Set auth mode on component mount
  useEffect(() => {
    setState((prev) => ({ ...prev, authMode }));
  }, [authMode]);

  const extractUserFromToken = useCallback((token: string) => {
    try {
      const claims = jwtDecode<TokenClaims>(token);
      const email = claims['urn:myapp:email'] || claims.email || '';

      return {
        id: claims.sub,
        email,
      };
    } catch (error) {
      /* decode token failure ignored */
      return null;
    }
  }, []);

  const login = useCallback(async () => {
    setState((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      if (authMode === 'dev' && devAuth) {
        // Dev mode: get token from local service
        const token = await devAuth.getValidToken();
        const user = extractUserFromToken(token);

        if (!user) {
          throw new Error('Invalid token received from dev service');
        }

        setState((prev) => ({
          ...prev,
          isAuthenticated: true,
          isLoading: false,
          user,
          token,
          error: null,
        }));
      } else {
        // Production mode: would use WorkOS OAuth flow
        throw new Error('Production auth not implemented yet');
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Authentication failed';
      setState((prev) => ({
        ...prev,
        isAuthenticated: false,
        isLoading: false,
        user: null,
        token: null,
        error: errorMessage,
      }));
    }
  }, [authMode, devAuth, extractUserFromToken]);

  const logout = useCallback(() => {
    if (devAuth) {
      devAuth.clearCache();
    }

    setState((prev) => ({
      ...prev,
      isAuthenticated: false,
      isLoading: false,
      user: null,
      token: null,
      error: null,
    }));
  }, [devAuth]);

  const getAuthHeaders = useCallback(async (): Promise<Record<string, string>> => {
    if (authMode === 'dev' && devAuth) {
      return await devAuth.getAuthHeaders();
    }

    if (state.token) {
      return { Authorization: `Bearer ${state.token}` };
    }

    return {};
  }, [authMode, devAuth, state.token]);

  const refreshToken = useCallback(async () => {
    if (authMode === 'dev' && devAuth) {
      devAuth.clearCache();
      await login();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [authMode, devAuth]); // Intentionally omitting login to avoid circular dependency

  // Auto-login in dev mode on mount
  useEffect(() => {
    if (authMode === 'dev' && state.isLoading) {
      login().catch((_error) => {
        /* auto login failed */
        setState((prev) => ({ ...prev, isLoading: false }));
      });
    } else if (authMode === 'production') {
      setState((prev) => ({ ...prev, isLoading: false }));
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [authMode, state.isLoading]); // Intentionally omitting login to avoid circular dependency

  const contextValue: AuthState & AuthActions = {
    ...state,
    login,
    logout,
    getAuthHeaders,
    refreshToken,
  };

  return <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>;
}


===== FILE: apps/chat/src/components/auth/AuthStatus.tsx =====

import { useAuth } from '../../lib/auth';

export function AuthStatus() {
  const { isAuthenticated, isLoading, user, error, authMode, login, logout } = useAuth();

  if (isLoading) {
    return (
      <div
        style={{
          padding: '1rem',
          backgroundColor: '#f0f9ff',
          border: '1px solid #0ea5e9',
          borderRadius: '8px',
          marginTop: '1rem',
        }}
      >
        <h3>ğŸ”„ Authentication Loading...</h3>
        <p>
          Auth mode: <strong>{authMode}</strong>
        </p>
      </div>
    );
  }

  if (error) {
    return (
      <div
        style={{
          padding: '1rem',
          backgroundColor: '#fef2f2',
          border: '1px solid #ef4444',
          borderRadius: '8px',
          marginTop: '1rem',
        }}
      >
        <h3>âŒ Authentication Error</h3>
        <p>
          <strong>Error:</strong> {error}
        </p>
        <p>
          Auth mode: <strong>{authMode}</strong>
        </p>
        {authMode === 'dev' && (
          <div style={{ marginTop: '0.5rem', fontSize: '0.875rem', color: '#666' }}>
            <p>Make sure the local dev service is running:</p>
            <code>cd apps/local-dev-service && npm run dev:start</code>
          </div>
        )}
        <button
          onClick={login}
          style={{
            marginTop: '0.5rem',
            padding: '0.5rem 1rem',
            backgroundColor: '#3b82f6',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          Retry Login
        </button>
      </div>
    );
  }

  if (isAuthenticated && user) {
    return (
      <div
        style={{
          padding: '1rem',
          backgroundColor: '#f0fdf4',
          border: '1px solid #22c55e',
          borderRadius: '8px',
          marginTop: '1rem',
        }}
      >
        <h3>âœ… Authenticated</h3>
        <p>
          <strong>User:</strong> {user.email}
        </p>
        <p>
          <strong>ID:</strong> {user.id}
        </p>
        <p>
          <strong>Auth mode:</strong> {authMode}
        </p>
        <button
          onClick={logout}
          style={{
            marginTop: '0.5rem',
            padding: '0.5rem 1rem',
            backgroundColor: '#ef4444',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          Logout
        </button>
      </div>
    );
  }

  return (
    <div
      style={{
        padding: '1rem',
        backgroundColor: '#f9fafb',
        border: '1px solid #d1d5db',
        borderRadius: '8px',
        marginTop: '1rem',
      }}
    >
      <h3>ğŸ” Not Authenticated</h3>
      <p>
        Auth mode: <strong>{authMode}</strong>
      </p>
      <button
        onClick={login}
        style={{
          marginTop: '0.5rem',
          padding: '0.5rem 1rem',
          backgroundColor: '#3b82f6',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
        }}
      >
        Login
      </button>
    </div>
  );
}


===== FILE: apps/chat/src/components/auth/RootProviders.tsx =====

import { Component, ReactNode, ErrorInfo, useRef, useEffect } from 'react';
import { AuthKitProvider } from '@workos-inc/authkit-react';
import { ConvexProviderWithAuth, ConvexProvider } from 'convex/react';
import { convex } from '@/lib/convex';
import { useDevConvexAuth } from '@/lib/useDevConvexAuth';
import { useAuthFromWorkOS } from '@/lib/useAuthFromWorkOS';
import { AuthContext } from '@/lib/auth';
import { getValidatedWorkOSConfig } from '@/lib/workosConfig';

const MODE = (import.meta.env.VITE_AUTH_MODE || 'dev') as 'dev' | 'workos';

class ErrorBoundary extends Component<{ children: ReactNode }, { hasError: boolean }> {
  constructor(props: { children: ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(): { hasError: boolean } {
    return { hasError: true };
  }

  componentDidCatch(error: unknown, errorInfo: ErrorInfo): void {
    // Swallow provider init errors to keep app usable; log for diagnostics
    // TODO(telemetry): Send error and errorInfo to telemetry once implemented
    console.error('Auth provider boundary caught an error', error, errorInfo);
  }

  render(): ReactNode {
    if (this.state.hasError) {
      return (
        <div style={{ padding: '1rem', color: '#b91c1c' }}>
          Authentication provider failed to initialize. Please refresh.
        </div>
      );
    }
    return this.props.children;
  }
}

export function RootProviders({ children }: { children: ReactNode }) {
  return (
    <ErrorBoundary>
      {MODE === 'workos' ? (
        <WorkOSProviders>{children}</WorkOSProviders>
      ) : (
        <DevAuthShim>{children}</DevAuthShim>
      )}
    </ErrorBoundary>
  );
}

function WorkOSProviders({ children }: { children: ReactNode }) {
  let cfg: { clientId: string; redirectUri: string } | null = null;
  try {
    cfg = getValidatedWorkOSConfig();
  } catch {
    /* render fallback below */
  }
  if (!cfg) {
    return (
      <div style={{ padding: '1rem', color: '#b91c1c' }}>
        Missing WorkOS env vars (VITE_WORKOS_CLIENT_ID / VITE_WORKOS_REDIRECT_URI)
      </div>
    );
  }

  return (
    <AuthKitProvider clientId={cfg.clientId} redirectUri={cfg.redirectUri}>
      <WorkOSConvexProvider>{children}</WorkOSConvexProvider>
    </AuthKitProvider>
  );
}

function WorkOSConvexProvider({ children }: { children: ReactNode }) {
  // Wrap the WorkOS auth state in a ref so we can hand Convex a *stable* hook
  // identity. Convex resets auth state whenever the function identity changes.
  const latestAuth = useAuthFromWorkOS();
  const authRef = useRef(latestAuth);
  authRef.current = latestAuth; // keep snapshot fresh

  const useStableAuth = () => authRef.current;

  return (
    <ConvexProviderWithAuth client={convex} useAuth={useStableAuth}>
      {children}
    </ConvexProviderWithAuth>
  );
}
function DevAuthShim({ children }: { children: ReactNode }) {
  const dev = useDevConvexAuth();

  // Build auth context value expected by existing components
  const authContextValue = {
    isAuthenticated: !!dev.token,
    isLoading: dev.isLoading,
    user: dev.user,
    token: dev.token,
    error: dev.error,
    authMode: 'dev' as const,
    login: dev.login,
    logout: dev.logout,
    refreshToken: dev.refreshToken,
    getAuthHeaders: async (): Promise<Record<string, string>> => {
      if (dev.token) return { Authorization: `Bearer ${dev.token}` };
      return {};
    },
  };
  // --- Convex docs note: if the useAuth prop function identity changes, Convex resets to loading.
  // We keep a stable function identity and feed it the latest state via refs so Convex doesn't churn.
  const authStateRef = useRef({
    isLoading: dev.isLoading,
    isAuthenticated: !!dev.token,
    fetchAccessToken: async (_opts?: { forceRefreshToken?: boolean }) => dev.token ?? null,
  });
  // Update ref each render with latest snapshot (no new function identity passed to Convex).
  useEffect(() => {
    authStateRef.current = {
      isLoading: dev.isLoading,
      isAuthenticated: !!dev.token,
      fetchAccessToken: async (_opts?: { forceRefreshToken?: boolean }) => {
        return dev.token ?? null;
      },
    };
  }, [dev.isLoading, dev.token]);

  const _useDevAuth = () => authStateRef.current;

  // Manual auth path: set token directly on convex client
  useEffect(() => {
    if (dev.token) {
      convex.setAuth(async () => dev.token as string);
    } else {
      convex.clearAuth();
    }
  }, [dev.token]);

  return (
    <AuthContext.Provider value={authContextValue}>
      <ConvexProvider client={convex}>{children}</ConvexProvider>
    </AuthContext.Provider>
  );
}


===== FILE: apps/chat/src/components/auth/WorkOSAuthStatus.tsx =====

import { useAuth } from '@workos-inc/authkit-react';

export function WorkOSAuthStatus() {
  const { user, signIn, signOut } = useAuth();
  return (
    <div
      style={{
        padding: '1rem',
        backgroundColor: '#f0f9ff',
        border: '1px solid #0ea5e9',
        borderRadius: '8px',
        marginTop: '1rem',
      }}
    >
      <h3>WorkOS Authentication</h3>
      <div style={{ marginTop: '0.5rem' }}>
        <button
          onClick={() => (user ? signOut() : void signIn())}
          style={{
            padding: '0.5rem 1rem',
            backgroundColor: '#3b82f6',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          {user ? 'Sign out' : 'Sign in'}
        </button>
        {user ? <span style={{ marginLeft: '0.5rem' }}>Logged in as {user.email}</span> : null}
      </div>
    </div>
  );
}


===== FILE: apps/chat/src/components/chat/ArtifactChip.tsx =====

import type React from 'react'
import type { Artifact } from '@/types/chat'

export const ArtifactChip: React.FC<{
  artifact: Artifact
  onRemove?: () => void
}> = ({ artifact, onRemove }) => {
  const icon =
    artifact.type === 'doc' ? 'ğŸ“„' : artifact.type === 'code' ? 'ğŸ’»' : artifact.type === 'img' ? 'ğŸ–¼ï¸' : 'ğŸ“Š'
  return (
    <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-zinc-100 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 text-[11px] text-zinc-700 dark:text-zinc-300">
      <span aria-hidden>{icon}</span>
      <span className="max-w-[180px] truncate">{artifact.name}</span>
      {onRemove && (
        <button
          onClick={onRemove}
          className="ml-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-700 px-1"
          aria-label={`Remove ${artifact.name}`}
        >
          Ã—
        </button>
      )}
    </span>
  )
}

export default ArtifactChip



===== FILE: apps/chat/src/components/chat/ArtifactPicker.tsx =====

import type React from 'react'
import { useMemo, useState } from 'react'
import { MOCK_ARTIFACTS } from '@/devapi/mockArtifacts'

interface ArtifactPickerProps {
  initialSelected?: string[]
  onConfirm: (ids: string[]) => void
  onCancel: () => void
}

export const ArtifactPicker: React.FC<ArtifactPickerProps> = ({ initialSelected = [], onConfirm, onCancel }) => {
  const [selected, setSelected] = useState<Set<string>>(new Set(initialSelected))
  const toggle = (id: string) => {
    setSelected((prev) => {
      const next = new Set(prev)
      if (next.has(id)) next.delete(id)
      else next.add(id)
      return next
    })
  }
  const list = useMemo(() => MOCK_ARTIFACTS, [])
  return (
    <div className="p-3 bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-700 rounded-lg shadow-lg w-80">
      <div className="text-sm font-medium mb-2 text-zinc-800 dark:text-zinc-100">Attach artifacts</div>
      <div className="max-h-56 overflow-auto divide-y divide-zinc-200 dark:divide-zinc-800" role="listbox" aria-label="Artifacts">
        {list.map((a) => (
          <label key={a.id} className="flex items-center gap-2 py-2 cursor-pointer text-sm">
            <input
              type="checkbox"
              checked={selected.has(a.id)}
              onChange={() => toggle(a.id)}
              aria-label={`Select ${a.name}`}
            />
            <span className="w-5 text-center" aria-hidden>
              {a.type === 'doc' ? 'ğŸ“„' : a.type === 'code' ? 'ğŸ’»' : a.type === 'img' ? 'ğŸ–¼ï¸' : 'ğŸ“Š'}
            </span>
            <span className="truncate text-zinc-800 dark:text-zinc-200">{a.name}</span>
          </label>
        ))}
      </div>
      <div className="mt-3 flex justify-end gap-2">
        <button onClick={onCancel} className="px-3 py-1.5 text-sm rounded border border-zinc-300 dark:border-zinc-700">Cancel</button>
        <button
          onClick={() => onConfirm(Array.from(selected))}
          className="px-3 py-1.5 text-sm rounded bg-zinc-900 text-white dark:bg-zinc-200 dark:text-zinc-900"
        >
          Attach
        </button>
      </div>
    </div>
  )
}

export default ArtifactPicker



===== FILE: apps/chat/src/components/chat/CenterChatShell.tsx =====

import type React from 'react';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import MessageView from './ChatMessage';
import { useChatStream } from '../../hooks/useChatStream';
import { Composer } from './Composer';
import type { Capability } from '@/types/chat';
import { ProvenancePill } from './ProvenancePill';

interface CenterChatShellProps {
  threadId: string;
  capability: Capability;
  onScrollChange?: (scrolled: boolean) => void;
}

const ESTIMATED_ROW_PX = 88;
const BUFFER_ROWS = 6;

export const CenterChatShell: React.FC<CenterChatShellProps> = ({
  threadId,
  capability,
  onScrollChange,
}) => {
  const { messages, status, error, send, cancel, retry } = useChatStream(threadId, capability);

  const scrollRef = useRef<HTMLDivElement | null>(null);
  const lastOverlay = useRef<boolean>(false);
  const [scrollTop, setScrollTop] = useState(0);
  const [clientHeight, setClientHeight] = useState(0);
  const [showJump, setShowJump] = useState(false);

  const handleScroll = useCallback(() => {
    const el = scrollRef.current;
    if (!el) return;
    const scTop = el.scrollTop;
    // Show a subtle top fade only when near the top (but not at exact top)
    // Standard behavior: show overlay whenever content is scrolled away from top
    const showOverlay = scTop > 0;
    if (showOverlay !== lastOverlay.current) {
      lastOverlay.current = showOverlay;
      onScrollChange?.(showOverlay);
    }
    setScrollTop(scTop);
    setClientHeight(el.clientHeight);
    const distanceFromBottom = el.scrollHeight - scTop - el.clientHeight;
    setShowJump(distanceFromBottom > 300);
  }, [onScrollChange]);

  useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;
    // Initialize
    handleScroll();
    el.addEventListener('scroll', handleScroll);
    return () => {
      el.removeEventListener('scroll', handleScroll);
    };
  }, [handleScroll]);

  // Simple windowing based on estimated heights
  const total = messages.length;
  const startIndex = Math.max(0, Math.floor(scrollTop / ESTIMATED_ROW_PX) - BUFFER_ROWS);
  const endIndex = Math.min(
    total,
    Math.ceil((scrollTop + clientHeight) / ESTIMATED_ROW_PX) + BUFFER_ROWS,
  );
  const visible = useMemo(
    () => messages.slice(startIndex, endIndex),
    [messages, startIndex, endIndex],
  );
  const topSpacer = startIndex * ESTIMATED_ROW_PX;
  const bottomSpacer = Math.max(0, (total - endIndex) * ESTIMATED_ROW_PX);

  const jumpToBottom = useCallback(() => {
    const el = scrollRef.current;
    if (!el) return;
    el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
  }, []);

  return (
    <div className="flex flex-col h-full" data-testid="center-chat">
      {/* Subheader */}
      <div className="px-6 py-3 border-b border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-950">
        <div className="text-sm text-zinc-500 dark:text-zinc-400">
          Chat Session â€” Ready for streaming Â· {messages.length} messages
        </div>
      </div>

      {/* Messages Container - Ready for virtualization */}
      <div
        ref={scrollRef}
        className="flex-1 overflow-y-auto px-6 py-4"
        data-testid="center-chat-list"
        tabIndex={0}
        onKeyDown={(e) => {
          if (e.key === 'End') {
            e.preventDefault();
            jumpToBottom();
          }
        }}
      >
        {/* Windowed list */}
        <div style={{ height: topSpacer }} />
        <div className="space-y-4">
          {visible.map((m) => (
            <div key={m.id} className="space-y-1">
              <MessageView message={m} />
              {m.role === 'assistant' && m.metadata?.provenance && (
                <div className="pl-4">
                  <ProvenancePill provenance={m.metadata.provenance} />
                </div>
              )}
            </div>
          ))}
          {status === 'error' && (
            <div className="text-sm text-red-600 dark:text-red-400">
              {error || 'Stream error'}
              <button
                className="ml-3 px-2 py-1 rounded bg-zinc-900 text-white text-xs dark:bg-zinc-200 dark:text-zinc-900"
                onClick={retry}
              >
                Retry
              </button>
            </div>
          )}
        </div>
        <div style={{ height: bottomSpacer }} />

        {showJump && (
          <button
            onClick={jumpToBottom}
            className="fixed bottom-24 right-6 px-3 py-2 rounded-full bg-zinc-900 text-white text-xs shadow-md hover:bg-zinc-800 dark:bg-zinc-200 dark:text-zinc-900 dark:hover:bg-white"
          >
            Jump to bottom
          </button>
        )}
      </div>

      {/* Sticky Composer */}
      <div
        className="border-t border-zinc-200 dark:border-zinc-800 p-4 bg-white dark:bg-zinc-950"
        data-testid="composer"
      >
        <div className="max-w-4xl mx-auto">
          <Composer
            status={status}
            onSend={(t, opts) => {
              const nearBottom = (() => {
                const el = scrollRef.current;
                if (!el) return true;
                const distance = el.scrollHeight - el.scrollTop - el.clientHeight;
                return distance < 200;
              })();
              send(t, {
                onToken: () => {
                  if (nearBottom) {
                    // Re-evaluate nearness each token; if still near, keep pinned
                    const el = scrollRef.current;
                    if (!el) return;
                    const distance = el.scrollHeight - el.scrollTop - el.clientHeight;
                    if (distance < 200) el.scrollTop = el.scrollHeight;
                  }
                },
                artifactIds: opts?.artifactIds,
              });
            }}
            onCancel={cancel}
          />
        </div>
      </div>
    </div>
  );
};


===== FILE: apps/chat/src/components/chat/ChatMessage.tsx =====

import type React from 'react';
import { useMemo } from 'react';
import type { ChatMessage as ChatMsg } from '@/types/chat';
import { MOCK_ARTIFACTS_MAP } from '@/devapi/mockArtifacts';
import { ArtifactChip } from './ArtifactChip';

function formatTime(ts: number): string {
  try {
    const d = new Date(ts);
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  } catch {
    return '';
  }
}

function parseBlocks(text: string): Array<{ type: 'code' | 'text'; content: string }> {
  const lines = text.split(/\r?\n/);
  const parts: Array<{ type: 'code' | 'text'; content: string }> = [];
  let inCode = false;
  let buffer: string[] = [];

  const flush = (type: 'code' | 'text') => {
    if (buffer.length) {
      parts.push({ type, content: buffer.join('\n') });
      buffer = [];
    }
  };

  for (const line of lines) {
    if (line.trim().startsWith('```') && !inCode) {
      // start code block
      flush('text');
      inCode = true;
      continue;
    }
    if (line.trim().startsWith('```') && inCode) {
      // end code block
      flush('code');
      inCode = false;
      continue;
    }
    buffer.push(line);
  }

  flush(inCode ? 'code' : 'text');
  return parts;
}

export default function ChatMessage({ message }: { message: ChatMsg }) {
  const isUser = message.role === 'user';
  const isAssistant = message.role === 'assistant';
  const isSystem = message.role === 'system';

  const containerAlign = isUser ? 'justify-end' : 'justify-start';
  const bubbleClass = isSystem
    ? 'border border-zinc-200 dark:border-zinc-700 bg-transparent'
    : isUser
      ? 'bg-zinc-100 dark:bg-zinc-900 ml-12'
      : 'bg-sky-50 dark:bg-sky-900/20 mr-12';

  const parts = useMemo(() => parseBlocks(message.text), [message.text]);

  const copy = async () => {
    try {
      await navigator.clipboard.writeText(message.text);
    } catch {
      // no-op
    }
  };

  return (
    <div className={`flex ${containerAlign}`} data-testid={`msg-${message.id}`}>
      <div className={`max-w-2xl rounded-lg p-4 ${bubbleClass}`}>
        <div className="flex items-start gap-3">
          {/* Avatar placeholder */}
          <div
            className={`w-8 h-8 rounded-full mt-0.5 ${
              isUser
                ? 'bg-zinc-300'
                : isAssistant
                  ? 'bg-sky-200 dark:bg-sky-800'
                  : 'bg-zinc-200 dark:bg-zinc-700'
            }`}
            aria-hidden="true"
          />
          <div className="flex-1">
            {parts.map((p, idx) =>
              p.type === 'code' ? (
                <pre
                  key={idx}
                  className="font-mono text-[13px] whitespace-pre overflow-auto rounded bg-zinc-50 dark:bg-zinc-900 p-3 mb-2"
                >
                  {p.content}
                </pre>
              ) : (
                <div key={idx} className="whitespace-pre-wrap text-zinc-900 dark:text-zinc-100">
                  {p.content}
                </div>
              ),
            )}
            {message.metadata?.artifactIds && message.metadata.artifactIds.length > 0 && (
              <div className="mt-2 flex flex-wrap gap-2">
                {message.metadata.artifactIds.map((id) => {
                  const a = MOCK_ARTIFACTS_MAP[id];
                  if (!a) return null;
                  return <ArtifactChip key={id} artifact={a} />;
                })}
              </div>
            )}
            <div className="mt-2 flex items-center gap-3 text-[11px] text-zinc-500 dark:text-zinc-400">
              <span>{formatTime(message.ts)}</span>
              <button
                onClick={copy}
                className="px-2 py-0.5 rounded border border-zinc-200 dark:border-zinc-700 hover:bg-zinc-100 dark:hover:bg-zinc-800"
                aria-label="Copy message"
              >
                Copy
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


===== FILE: apps/chat/src/components/chat/Composer.tsx =====

import type React from 'react';
import { useEffect, useRef, useState } from 'react';
import type { StreamStatus } from '../../types/chat';
import { ArtifactPicker } from './ArtifactPicker';
import { ArtifactChip } from './ArtifactChip';
import { MOCK_ARTIFACTS_MAP } from '@/devapi/mockArtifacts';

interface ComposerProps {
  onSend: (text: string, opts?: { artifactIds?: string[] }) => void;
  onCancel: () => void;
  status: StreamStatus;
}

export const Composer: React.FC<ComposerProps> = ({ onSend, onCancel, status }) => {
  const [value, setValue] = useState('');
  const ref = useRef<HTMLTextAreaElement | null>(null);
  const [showPicker, setShowPicker] = useState(false);
  const [artifactIds, setArtifactIds] = useState<string[]>([]);

  useEffect(() => {
    const el = ref.current;
    if (!el) return;
    el.style.height = '0px';
    el.style.height = Math.min(200, el.scrollHeight) + 'px';
  }, [value]);

  const disabled = status === 'sending' || status === 'streaming';

  const doSend = () => {
    const text = value.trim();
    if (!text || text.length > 8000) return;
    onSend(text, { artifactIds });
    setValue('');
    setArtifactIds([]);
    // return focus to textarea
    requestAnimationFrame(() => ref.current?.focus());
  };

  return (
    <div className="flex gap-3 relative">
      <button
        className="px-3 py-2 text-sm rounded border border-zinc-300 dark:border-zinc-700 text-zinc-700 dark:text-zinc-200 hover:bg-zinc-100 dark:hover:bg-zinc-800"
        title="Attach artifacts"
        onClick={() => setShowPicker((s) => !s)}
        disabled={disabled}
      >
        +
      </button>
      <textarea
        ref={ref}
        aria-label="Message"
        data-testid="composer-input"
        className="flex-1 resize-none rounded-lg border border-zinc-300 dark:border-zinc-600 px-4 py-3 text-sm bg-white dark:bg-zinc-900 text-zinc-900 dark:text-zinc-100 focus:outline-none"
        placeholder="Type your message..."
        rows={1}
        value={value}
        onChange={(e) => setValue(e.target.value)}
        onKeyDown={(e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            if (!disabled) doSend();
          }
        }}
        disabled={disabled}
      />
      {showPicker && (
        <div className="absolute bottom-14 left-0 z-10">
          <ArtifactPicker
            initialSelected={artifactIds}
            onCancel={() => setShowPicker(false)}
            onConfirm={(ids) => {
              setArtifactIds(ids);
              setShowPicker(false);
            }}
          />
        </div>
      )}
      {disabled ? (
        <button
          data-testid="composer-stop"
          aria-pressed
          onClick={onCancel}
          className="px-4 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700"
        >
          Stop
        </button>
      ) : (
        <button
          data-testid="composer-send"
          onClick={doSend}
          className="px-4 py-3 bg-zinc-900 text-white rounded-lg hover:bg-zinc-800 dark:bg-zinc-200 dark:text-zinc-900 dark:hover:bg-white"
        >
          Send
        </button>
      )}
      {/* Selected chips */}
      {artifactIds.length > 0 && (
        <div className="absolute -top-8 left-12 right-0 flex flex-wrap gap-2">
          {artifactIds.map((id) => {
            const a = MOCK_ARTIFACTS_MAP[id];
            if (!a) return null;
            return <ArtifactChip key={id} artifact={a} onRemove={() => setArtifactIds((arr) => arr.filter((x) => x !== id))} />
          })}
        </div>
      )}
    </div>
  );
};

export default Composer;


===== FILE: apps/chat/src/components/chat/ProvenancePill.tsx =====

import type React from 'react';
import type { MessageProvenance } from '@/types/chat';

const CAP_LABEL: Record<MessageProvenance['capability'], string> = {
  fast: 'Fast',
  smart: 'Smart',
  deep: 'Deep',
  'deep-thinking': 'Deep+T',
};

export const ProvenancePill: React.FC<{ provenance: MessageProvenance }> = ({ provenance }) => {
  const parts: string[] = [];
  parts.push(CAP_LABEL[provenance.capability]);
  if (provenance.brandHint) parts.push(provenance.brandHint);

  const metrics: string[] = [];
  if (typeof provenance.latencyMs === 'number') metrics.push(`${provenance.latencyMs}ms`);
  if (typeof provenance.tokensIn === 'number') metrics.push(`${provenance.tokensIn} in`);
  if (typeof provenance.tokensOut === 'number') metrics.push(`${provenance.tokensOut} out`);

  return (
    <div className="inline-flex items-center gap-2 text-[11px] text-zinc-600 dark:text-zinc-400">
      <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-zinc-100 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700">
        <span className="font-medium">{parts.join(' Â· ')}</span>
        {metrics.length > 0 && <span className="text-zinc-500">Â· {metrics.join(' Â· ')}</span>}
      </span>
      {provenance.whyChosen && <span className="text-zinc-500">â€” {provenance.whyChosen}</span>}
    </div>
  );
};

export default ProvenancePill;


===== FILE: apps/chat/src/components/health/ConvexQueryTest.tsx =====

import { useQuery } from 'convex/react';
import { api } from '@liminal/api/convex/_generated/api';

export function ConvexQueryTest() {
  // Test real-time subscription with authenticated query
  const conversations = useQuery(api.db.conversations.list, {
    archived: false,
    paginationOpts: { numItems: 5 },
  });

  return (
    <div
      style={{
        padding: '1rem',
        backgroundColor: '#f0f9ff',
        border: '1px solid #0ea5e9',
        borderRadius: '8px',
        marginTop: '1rem',
      }}
    >
      <h3>âš¡ Real-time Convex Query Test</h3>
      <p>Testing authenticated Convex subscriptions</p>

      <div style={{ marginTop: '1rem' }}>
        <strong>Conversations Query Status:</strong>
        {conversations === undefined ? (
          <div style={{ color: '#f59e0b' }}>ğŸ”„ Loading...</div>
        ) : (
          <div style={{ color: '#10b981' }}>
            âœ… Loaded {conversations.page.length} conversations
            <pre
              style={{
                backgroundColor: '#f1f5f9',
                padding: '0.5rem',
                borderRadius: '4px',
                fontSize: '0.75rem',
                marginTop: '0.5rem',
                maxHeight: '200px',
                overflow: 'auto',
              }}
            >
              {JSON.stringify(conversations, null, 2)}
            </pre>
          </div>
        )}
      </div>
    </div>
  );
}


===== FILE: apps/chat/src/components/health/HealthCheck.tsx =====

import { useQuery } from 'convex/react';
import { api } from '@liminal/api/convex/_generated/api';

export function HealthCheck() {
  // Test authenticated Convex connection with a simple query
  const conversations = useQuery(api.db.conversations.list, {
    archived: false,
    paginationOpts: { numItems: 1 },
  });

  return (
    <div
      style={{
        padding: '1rem',
        backgroundColor: '#f8fafc',
        border: '1px solid #e2e8f0',
        borderRadius: '8px',
        marginTop: '1rem',
      }}
    >
      <h3>ğŸ”¬ Authenticated Health Check</h3>
      <p>Testing authenticated connection to Convex backend</p>

      <div style={{ marginTop: '1rem' }}>
        <strong>Convex Query Status:</strong>
        {conversations === undefined ? (
          <div style={{ color: '#f59e0b' }}>ğŸ”„ Loading authenticated query...</div>
        ) : (
          <div style={{ color: '#10b981' }}>
            âœ… Authenticated connection successful!
            <div
              style={{
                fontSize: '0.875rem',
                marginTop: '0.5rem',
                color: '#6b7280',
              }}
            >
              Query returned {conversations.page.length} conversation(s)
            </div>
          </div>
        )}
      </div>
    </div>
  );
}


===== FILE: apps/chat/src/components/layout/Panel.tsx =====

import type React from 'react';
import { useEffect, useRef } from 'react';

interface PanelProps {
  side: 'left' | 'right';
  isOpen: boolean;
  width: number;
  isDesktop: boolean;
  onToggle: () => void;
  children: React.ReactNode;
  'data-testid'?: string;
}

export const Panel: React.FC<PanelProps> = ({
  side,
  isOpen,
  width: _width,
  isDesktop,
  onToggle,
  children,
  'data-testid': testId,
}) => {
  const drawerRef = useRef<HTMLDivElement | null>(null);

  // Lock body scroll and handle Escape close while open (for mobile)
  useEffect(() => {
    if (isDesktop || !isOpen) return;
    const previous = document.body.style.overflow;
    document.body.style.overflow = 'hidden';

    const onKey = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        onToggle();
      }
    };
    document.addEventListener('keydown', onKey);
    drawerRef.current?.focus();

    return () => {
      document.body.style.overflow = previous;
      document.removeEventListener('keydown', onKey);
    };
  }, [isDesktop, isOpen, onToggle]);

  // Desktop: render static side panel only when open
  if (isDesktop) {
    if (!isOpen) return null;
    return (
      <div
        className={
          side === 'left'
            ? 'hidden lg:block border-r border-zinc-200 dark:border-zinc-800'
            : 'hidden lg:block border-l border-zinc-200 dark:border-zinc-800'
        }
        style={{ width: _width }}
        data-testid={testId}
      >
        {children}
      </div>
    );
  }

  // Mobile: render drawer + backdrop only when open
  if (!isOpen) return null;
  return (
    <>
      <div className="fixed inset-0 bg-black/20 z-40" onClick={onToggle} aria-hidden="true" />
      <div
        ref={drawerRef}
        tabIndex={-1}
        className={`fixed top-14 bottom-0 z-50 w-80 bg-white dark:bg-zinc-950 shadow-xl transition-transform ${
          side === 'left'
            ? 'left-0 border-r border-zinc-200 dark:border-zinc-800'
            : 'right-0 border-l border-zinc-200 dark:border-zinc-800'
        }`}
        data-testid={testId}
      >
        {children}
      </div>
    </>
  );
};


===== FILE: apps/chat/src/components/layout/Resizer.tsx =====

'use client';

import type React from 'react';
import { useCallback, useEffect, useRef } from 'react';

interface ResizerProps {
  side: 'left' | 'right';
  onResize: (width: number) => void;
  'data-testid'?: string;
}

export const Resizer: React.FC<ResizerProps> = ({ side, onResize, 'data-testid': testId }) => {
  const isDragging = useRef(false);
  const startX = useRef(0);
  const startWidth = useRef(0);

  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!isDragging.current) return;

      const deltaX = e.clientX - startX.current;
      const newWidth = side === 'left' ? startWidth.current + deltaX : startWidth.current - deltaX;

      // Clamp width between 240px and 420px
      const clampedWidth = Math.min(Math.max(newWidth, 240), 420);
      onResize(clampedWidth);
    },
    [side, onResize],
  );

  const handleMouseUp = useCallback(() => {
    if (!isDragging.current) return;

    isDragging.current = false;
    document.body.style.cursor = '';
    document.body.style.userSelect = '';

    // Remove listeners when drag ends
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  }, [handleMouseMove]);

  const handleMouseDown = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault();
      isDragging.current = true;
      startX.current = e.clientX;

      // Get current panel width
      const panel = e.currentTarget.previousElementSibling || e.currentTarget.nextElementSibling;
      if (panel) {
        startWidth.current = (panel as HTMLElement).getBoundingClientRect().width;
      }

      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';

      // Attach listeners on drag start
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    },
    [handleMouseMove, handleMouseUp],
  );

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [handleMouseMove, handleMouseUp]);

  return (
    <div
      className="w-1 bg-transparent hover:bg-zinc-300/40 dark:hover:bg-zinc-600/40 cursor-col-resize flex-shrink-0 group"
      onMouseDown={handleMouseDown}
      tabIndex={0}
      role="separator"
      aria-label={`Resize ${side} panel`}
      data-testid={testId}
      onKeyDown={(e) => {
        const key = e.key;
        if (key === 'Enter' || key === ' ') {
          e.preventDefault();
          return;
        }
        if (key !== 'ArrowLeft' && key !== 'ArrowRight') return;
        e.preventDefault();
        const panel = (e.currentTarget.previousElementSibling ||
          e.currentTarget.nextElementSibling) as HTMLElement | null;
        if (!panel) return;
        const current = panel.getBoundingClientRect().width;
        const delta = 16;
        let newWidth = current;
        if (side === 'left') {
          newWidth = key === 'ArrowLeft' ? current - delta : current + delta;
        } else {
          // Right panel grows when moving left
          newWidth = key === 'ArrowLeft' ? current + delta : current - delta;
        }
        const clampedWidth = Math.min(Math.max(newWidth, 240), 420);
        onResize(clampedWidth);
      }}
    >
      <div className="w-full h-full group-hover:bg-blue-500/20 group-focus:bg-blue-500/20 transition-colors" />
    </div>
  );
};


===== FILE: apps/chat/src/components/layout/TopBar.tsx =====

'use client';

import type React from 'react';

type Capability = 'fast' | 'smart' | 'deep' | 'deep-thinking';

interface TopBarProps {
  leftOpen: boolean;
  rightOpen: boolean;
  mode: Capability;
  onToggleLeft: () => void;
  onToggleRight: () => void;
  onSelectMode: (mode: Capability) => void;
  hasShadow?: boolean;
}

export const TopBar: React.FC<TopBarProps> = ({
  leftOpen,
  rightOpen,
  mode,
  onToggleLeft,
  onToggleRight,
  onSelectMode,
  hasShadow: _hasShadow = false,
}) => {
  const capabilities: { value: Capability; label: string }[] = [
    { value: 'fast', label: 'Fast' },
    { value: 'smart', label: 'Smart' },
    { value: 'deep', label: 'Deep' },
    { value: 'deep-thinking', label: 'Deep+T' },
  ];

  return (
    <div
      className={`h-14 bg-white dark:bg-zinc-950 border-b border-zinc-200 dark:border-zinc-800 flex items-center px-4 sticky top-0 z-50`}
      data-testid="topbar"
    >
      {/* Left Section */}
      <div className="flex items-center gap-3">
        <button
          onClick={onToggleLeft}
          className="p-2 rounded hover:bg-zinc-100 dark:hover:bg-zinc-800 focus:outline-none focus:ring-2 focus:ring-blue-500"
          aria-pressed={leftOpen}
          aria-label="Toggle left panel"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M4 6h16M4 12h16M4 18h16"
            />
          </svg>
        </button>

        <button className="px-3 py-1.5 text-sm bg-zinc-100 dark:bg-zinc-800 rounded hover:bg-zinc-200 dark:hover:bg-zinc-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
          Project Alpha
          <svg
            className="w-4 h-4 ml-1 inline"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
          </svg>
        </button>
      </div>

      {/* Center Title */}
      <div className="flex-1 flex justify-center">
        <h1 className="text-lg font-semibold text-zinc-900 dark:text-zinc-100">Chat App</h1>
      </div>

      {/* Right Section */}
      <div className="flex items-center gap-3">
        {/* Capability Selector */}
        <div
          className="flex bg-zinc-100 dark:bg-zinc-800 rounded-lg p-1"
          data-testid="mode-selector"
          role="radiogroup"
          aria-label="Select capability mode"
        >
          {capabilities.map((cap) => (
            <button
              key={cap.value}
              onClick={() => onSelectMode(cap.value)}
              className={`px-3 py-1 text-sm rounded transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                mode === cap.value
                  ? 'bg-white dark:bg-zinc-700 text-zinc-900 dark:text-zinc-100 shadow-sm'
                  : 'text-zinc-600 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-zinc-100'
              }`}
              role="radio"
              aria-checked={mode === cap.value}
            >
              {cap.label}
            </button>
          ))}
        </div>

        <button
          onClick={onToggleRight}
          className="p-2 rounded hover:bg-zinc-100 dark:hover:bg-zinc-800 focus:outline-none focus:ring-2 focus:ring-blue-500"
          aria-pressed={rightOpen}
          aria-label="Toggle right panel"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>
    </div>
  );
};


===== FILE: apps/chat/src/components/roundtable/RoundtableInterface.tsx =====

// Roundtable Interface Component
// Multi-agent chat interface with 3 agent boxes and user input

import React from 'react';
import type { RoundtableInterfaceProps } from './types';

export function RoundtableInterface({
  state,
  onUserInput,
  onAgentMention,
  onAgentModalOpen,
  onAgentModalClose,
  onAgentFocusedChatOpen,
  onAgentFocusedChatClose,
  onSend,
}: RoundtableInterfaceProps) {
  // Filter conversation history for each agent
  const getAgentConversation = (agentId: string) => {
    return state.conversationHistory.filter(
      (turn) =>
        // Show agent's own messages
        turn.author === agentId ||
        // Show user messages that mention this agent
        (turn.author === 'user' && turn.mentionedAgents?.includes(agentId)),
    );
  };

  const handleMentionClick = (agentId: string) => {
    onAgentMention?.(agentId);
  };

  return (
    <div className="flex flex-col h-full max-h-full w-full space-y-2">
      {/* User Input Section - at the top with mention buttons inside */}
      <UserInputSection
        state={state}
        onUserInput={onUserInput}
        onMentionClick={handleMentionClick}
        onSend={onSend}
      />

      {/* Agent Chatboxes - 3 across the bottom, maximizing vertical space */}
      <div className="flex flex-row gap-2 flex-1 min-h-0 w-full">
        {state.agents.map((agent) => (
          <AgentChatBox
            key={agent.id}
            agent={agent}
            conversation={getAgentConversation(agent.id)}
            onAgentNameClick={() => onAgentModalOpen?.(agent.id)}
            onAgentAvatarClick={() => onAgentFocusedChatOpen?.(agent.id)}
          />
        ))}
      </div>

      {/* Agent Modal */}
      {state.openAgentModal && (
        <AgentModal
          agent={state.agents.find((a) => a.id === state.openAgentModal)}
          onClose={() => onAgentModalClose?.()}
        />
      )}

      {/* Focused Agent Chat Modal */}
      {state.openFocusedChat && (
        <FocusedAgentChatModal
          agents={state.agents}
          currentAgentId={state.openFocusedChat}
          conversationHistory={state.conversationHistory}
          onClose={() => onAgentFocusedChatClose?.()}
          onNavigateAgent={(agentId: string) => onAgentFocusedChatOpen?.(agentId)}
        />
      )}
    </div>
  );
}

// Focused Agent Chat Modal Component
interface FocusedAgentChatModalProps {
  agents: Array<{ id: string; name: string; color?: string }>;
  currentAgentId: string;
  conversationHistory: Array<{
    id: string;
    type: string;
    author: string;
    content: string;
    timestamp: number;
    mentionedAgents?: string[];
  }>;
  onClose: () => void;
  onNavigateAgent: (agentId: string) => void;
}

function FocusedAgentChatModal({
  agents,
  currentAgentId,
  conversationHistory,
  onClose,
  onNavigateAgent,
}: FocusedAgentChatModalProps) {
  const currentAgent = agents.find((a) => a.id === currentAgentId);
  if (!currentAgent) return null;

  const currentAgentIndex = agents.findIndex((a) => a.id === currentAgentId);
  const canGoPrevious = currentAgentIndex > 0;
  const canGoNext = currentAgentIndex < agents.length - 1;

  const handlePrevious = () => {
    if (canGoPrevious) {
      onNavigateAgent(agents[currentAgentIndex - 1].id);
    }
  };

  const handleNext = () => {
    if (canGoNext) {
      onNavigateAgent(agents[currentAgentIndex + 1].id);
    }
  };

  // Get conversation from this agent's perspective (only messages involving them)
  const agentConversation = conversationHistory.filter(
    (turn) =>
      // Show agent's own messages
      turn.author === currentAgentId ||
      // Show user messages that mention this agent
      (turn.author === 'user' && turn.mentionedAgents?.includes(currentAgentId)),
  );

  const agentColor = currentAgent.color || '#6b7280';

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] h-[90vh] flex flex-col">
        {/* Header with navigation */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200">
          <button
            onClick={handlePrevious}
            disabled={!canGoPrevious}
            className="p-2 rounded-md hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            â† Previous Agent
          </button>

          <div className="flex items-center gap-3">
            <div
              className="w-8 h-8 rounded-full flex items-center justify-center text-white text-sm font-bold"
              style={{ backgroundColor: agentColor }}
            >
              {currentAgent.name.charAt(0)}
            </div>
            <h2 className="text-xl font-semibold text-gray-900">{currentAgent.name}</h2>
          </div>

          <button
            onClick={handleNext}
            disabled={!canGoNext}
            className="p-2 rounded-md hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Next Agent â†’
          </button>
        </div>

        {/* Conversation Area */}
        <div className="flex-1 p-4 overflow-y-auto space-y-3 min-h-0">
          {agentConversation.length === 0 ? (
            <div className="text-center text-gray-500 py-8">
              <div
                className="w-12 h-12 rounded-full flex items-center justify-center text-white text-lg font-bold mx-auto mb-3"
                style={{ backgroundColor: agentColor }}
              >
                {currentAgent.name.charAt(0)}
              </div>
              <p className="text-sm">No messages yet with {currentAgent.name}</p>
              <p className="text-xs text-gray-400 mt-1">
                Mention @{currentAgent.name.toLowerCase().replace(/\s+/g, '')} to start a
                conversation
              </p>
            </div>
          ) : (
            agentConversation.map((turn) => (
              <div key={turn.id} className="space-y-2">
                <div className={`flex gap-3 ${turn.author === 'user' ? 'flex-row-reverse' : ''}`}>
                  <div className="flex-1">
                    <div
                      className={`inline-block p-3 rounded-lg max-w-[80%] ${
                        turn.author === 'user' ? 'bg-gray-600 text-white ml-auto' : 'text-white'
                      }`}
                      style={turn.author !== 'user' ? { backgroundColor: agentColor } : {}}
                    >
                      {turn.content}
                    </div>
                    <p
                      className={`text-xs text-gray-500 mt-1 ${turn.author === 'user' ? 'text-right' : ''}`}
                    >
                      {new Date(turn.timestamp).toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit',
                      })}
                    </p>
                  </div>
                </div>
              </div>
            ))
          )}
        </div>

        {/* Input Area */}
        <div className="p-4 border-t border-gray-200">
          <div className="flex gap-3">
            <input
              type="text"
              placeholder={`Send a message to ${currentAgent.name}...`}
              className="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            <button className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
              Send
            </button>
          </div>
        </div>

        {/* Close Button */}
        <button
          onClick={onClose}
          className="absolute top-4 right-4 w-8 h-8 rounded-full bg-gray-200 hover:bg-gray-300 flex items-center justify-center text-gray-600"
        >
          âœ•
        </button>
      </div>
    </div>
  );
}

// Individual Agent Chat Box Component
interface AgentChatBoxProps {
  agent: { id: string; name: string; color?: string };
  conversation: Array<{
    id: string;
    type: string;
    author: string;
    content: string;
    timestamp: number;
  }>;
  onAgentNameClick: () => void;
  onAgentAvatarClick: () => void;
}

function AgentChatBox({
  agent,
  conversation,
  onAgentNameClick,
  onAgentAvatarClick,
}: AgentChatBoxProps) {
  const agentColor = agent.color || '#6b7280';
  const scrollRef = React.useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom when new messages are added
  React.useEffect(() => {
    const scrollToBottom = () => {
      if (scrollRef.current) {
        const element = scrollRef.current;
        element.scrollTop = element.scrollHeight - element.clientHeight;
      }
    };

    // Small delay to ensure DOM is updated
    const timer = setTimeout(scrollToBottom, 10);
    return () => clearTimeout(timer);
  }, [conversation.length, agent.id]);

  return (
    <div className="bg-white border border-gray-200 rounded shadow-sm flex flex-col h-full min-w-0 flex-1">
      {/* Agent Header - reduced size */}
      <div className="p-1 border-b border-gray-200 bg-gray-50 flex items-center gap-2">
        {/* Avatar - click for focused chat */}
        <button
          onClick={onAgentAvatarClick}
          className="w-6 h-6 rounded-full flex items-center justify-center text-white text-xs font-semibold hover:ring-2 hover:ring-blue-300 transition-all"
          style={{ backgroundColor: agentColor }}
          title="Open focused chat"
        >
          {agent.name.charAt(0)}
        </button>

        {/* Name area - click for agent config */}
        <button
          onClick={onAgentNameClick}
          className="flex-1 hover:bg-gray-100 p-1 rounded transition-colors text-left"
          title="View agent details"
        >
          <h3 className="text-xs font-semibold text-gray-900">{agent.name}</h3>
          <p className="text-xs text-gray-500">{conversation.length} messages</p>
        </button>
      </div>

      {/* Conversation Area - maximized vertical space */}
      <div ref={scrollRef} className="flex-1 p-2 overflow-y-auto space-y-1 min-h-0">
        {conversation.length === 0 ? (
          <div className="text-center text-gray-500 py-4">
            <div
              className="w-8 h-8 rounded-full flex items-center justify-center text-white text-xs font-bold mx-auto mb-2"
              style={{ backgroundColor: agentColor }}
            >
              {agent.name.charAt(0)}
            </div>
            <p className="text-xs">No messages yet</p>
            <p className="text-xs text-gray-400 mt-1">
              Mention @{agent.name.toLowerCase().replace(/\s+/g, '')} to start
            </p>
          </div>
        ) : (
          conversation.map((turn) => (
            <MessageBubble key={turn.id} turn={turn} agent={agent} agentColor={agentColor} />
          ))
        )}
      </div>
    </div>
  );
}

// Message Bubble Component
interface MessageBubbleProps {
  turn: { type: string; author: string; content: string; timestamp: number };
  agent: { id: string; name: string };
  agentColor: string;
}

function MessageBubble({ turn, agent, agentColor }: MessageBubbleProps) {
  const isUser = turn.author === 'user';
  const isThisAgent = turn.author === agent.id;

  return (
    <div className={`flex gap-1 ${isUser ? 'flex-row-reverse' : ''}`}>
      {/* Removed colored initials - messages now take full horizontal space */}
      <div className={`flex-1 ${isUser ? 'text-right' : ''}`}>
        <div
          className={`inline-block p-2 rounded text-xs ${
            isUser
              ? 'bg-gray-600 text-white'
              : isThisAgent
                ? 'text-white'
                : 'bg-gray-100 text-gray-900'
          }`}
          style={!isUser && isThisAgent ? { backgroundColor: agentColor } : {}}
        >
          {turn.content}
        </div>
        <p className="text-xs text-gray-500 mt-1">
          {new Date(turn.timestamp).toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit',
          })}
        </p>
      </div>
    </div>
  );
}

// User Input Section Component
interface UserInputSectionProps {
  state: {
    currentUserInput: string;
    availableAgentMentions: Array<{ agentId: string; agentName: string; insertText: string }>;
    awaitingUserInput?: boolean;
  };
  onUserInput?: (input: string) => void;
  onMentionClick: (agentId: string) => void;
  onSend?: () => void;
}

function UserInputSection({ state, onUserInput, onMentionClick, onSend }: UserInputSectionProps) {
  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    onUserInput?.(e.target.value);
  };
  const canSend = Boolean(state.awaitingUserInput) && Boolean(state.currentUserInput?.trim());

  return (
    <div className="bg-white border border-gray-200 rounded shadow-sm p-2">
      {/* Input Area with mention buttons at bottom */}
      <div className="relative">
        <textarea
          value={state.currentUserInput}
          onChange={handleInputChange}
          placeholder="Type your message to the roundtable..."
          className="w-full h-16 p-2 pr-20 pb-8 border border-gray-300 rounded resize-none focus:ring-1 focus:ring-blue-500 focus:border-transparent text-sm"
        />

        {/* Mention Buttons - positioned at bottom of textarea */}
        <div className="absolute bottom-1 left-1 flex gap-1">
          {state.availableAgentMentions.map((mention) => (
            <button
              key={mention.agentId}
              onClick={() => onMentionClick(mention.agentId)}
              className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition-colors"
            >
              {mention.insertText}
            </button>
          ))}
        </div>

        {/* Send Button */}
        <div className="absolute bottom-1 right-1">
          <button
            onClick={() => {
              if (canSend) onSend?.();
            }}
            disabled={!canSend}
            className="px-3 py-1 bg-blue-600 text-white text-xs font-medium rounded hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors"
          >
            Send
          </button>
        </div>
      </div>
    </div>
  );
}

// Agent Modal Component
interface AgentModalProps {
  agent?: { id: string; name: string; systemPrompt: string; color?: string };
  onClose: () => void;
}

function AgentModal({ agent, onClose }: AgentModalProps) {
  if (!agent) return null;

  const agentColor = agent.color || '#6b7280';

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[80vh] overflow-y-auto">
        <div className="p-6">
          {/* Agent Header */}
          <div className="flex items-center gap-4 mb-6">
            <div
              className="w-16 h-16 rounded-full flex items-center justify-center text-white text-xl font-bold"
              style={{ backgroundColor: agentColor }}
            >
              {agent.name.charAt(0)}
            </div>
            <div>
              <h2 className="text-xl font-semibold text-gray-900">{agent.name}</h2>
              <p className="text-sm text-gray-500">Agent Details</p>
            </div>
          </div>

          {/* Agent Info */}
          <div className="space-y-4">
            <div>
              <h3 className="text-sm font-medium text-gray-700 mb-2">Agent ID</h3>
              <p className="text-sm text-gray-600 font-mono bg-gray-50 p-2 rounded">{agent.id}</p>
            </div>

            <div>
              <h3 className="text-sm font-medium text-gray-700 mb-2">System Prompt</h3>
              <p className="text-sm text-gray-600 bg-gray-50 p-3 rounded leading-relaxed">
                {agent.systemPrompt}
              </p>
            </div>
          </div>

          {/* Close Button */}
          <div className="mt-6 flex justify-end">
            <button
              onClick={onClose}
              className="px-4 py-2 bg-gray-600 text-white text-sm font-medium rounded-md hover:bg-gray-700 transition-colors"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}


===== FILE: apps/chat/src/components/roundtable/RoundtableInterface2.tsx =====

import React, { useRef, useEffect } from 'react';
import { Agent as DemoAgent, RoundtableState, ConversationTurn } from '@/lib/types/roundtable';

interface Message {
  id: string;
  content: string;
  timestamp: string;
  isUser: boolean;
  agentId?: string;
}

interface Props {
  agents: DemoAgent[];
  messages: Message[];
  currentUserInput: string;
  onUserInputChange: (input: string) => void;
  onSendMessage: () => void;
  onMentionAgent: (agentId: string) => void;
  onAgentClick: (agentId: string) => void;
  isInputDisabled: boolean;
  demoState?: RoundtableState;
  openAgentModal?: string;
  openFocusedChat?: string;
  onAgentModalOpen?: (agentId: string) => void;
  onAgentModalClose?: () => void;
  onAgentFocusedChatOpen?: (agentId: string) => void;
  onAgentFocusedChatClose?: () => void;
  onNavigateAgent?: (agentId: string) => void;
}

// Agent Avatar Component
interface AgentAvatarProps {
  agent: DemoAgent;
  isActive: boolean;
  position?: number;
  isThinking?: boolean;
  onAvatarClick: (agentId: string) => void;
  onNameClick: (agentId: string) => void;
}

const positions = [
  { x: '-140px', y: '20px', rotate: '-15deg' },
  { x: '0px', y: '0px', rotate: '0deg' },
  { x: '140px', y: '20px', rotate: '15deg' },
];

function AgentAvatar({
  agent,
  isActive,
  position,
  isThinking = false,
  onAvatarClick,
  onNameClick,
}: AgentAvatarProps) {
  const pos = position !== undefined ? positions[position] : { x: '0px', y: '0px', rotate: '0deg' };

  const getInitial = (name: string) => name?.charAt(0)?.toUpperCase() || '?';

  if (isThinking) {
    return (
      <div
        className="relative h-12 w-12 rounded-full transition-all duration-300"
        style={{ backgroundColor: agent.color || '#6b7280' }}
      >
        <div className="flex h-full w-full items-center justify-center rounded-full border-2 border-white/50 text-xl font-bold text-white">
          {getInitial(agent.name)}
        </div>
      </div>
    );
  }

  return (
    <div
      className="relative flex flex-col items-center transition-all duration-300 hover:scale-105"
      style={{
        transform: `translateX(${pos.x}) translateY(${pos.y}) rotate(${pos.rotate})`,
        transformOrigin: 'center',
      }}
    >
      <div
        className={`relative h-14 w-14 rounded-full transition-all duration-300 cursor-pointer ${
          isActive ? 'scale-110 shadow-lg -translate-y-1' : 'scale-100'
        }`}
        style={{
          backgroundColor: agent.color || '#6b7280',
          boxShadow: isActive ? `0 0 20px 4px ${agent.color || '#6b7280'}40` : 'none',
        }}
        onClick={() => onAvatarClick(agent.id)}
      >
        <div className="flex h-full w-full items-center justify-center rounded-full border-2 border-white/20 text-2xl font-bold text-white">
          {getInitial(agent.name)}
        </div>
      </div>
      <span
        className="mt-2 text-sm font-medium text-white/80 cursor-pointer hover:text-white"
        onClick={() => onNameClick(agent.id)}
      >
        {agent.name}
      </span>
    </div>
  );
}

// Chat Message Component
interface ChatMessageProps {
  message: Message;
  agents: DemoAgent[];
}

function ChatMessage({ message, agents }: ChatMessageProps) {
  const agent = agents?.find((a) => a?.id === message.agentId);

  if (message.isUser) {
    return (
      <div className="flex justify-end">
        <div className="max-w-[70%] rounded-2xl bg-blue-600 px-4 py-3 text-white">
          <p className="text-sm">{message.content}</p>
          <span className="text-xs text-blue-200">{message.timestamp}</span>
        </div>
      </div>
    );
  }

  if (agent) {
    return (
      <div className="flex items-start space-x-3">
        <div
          className="h-8 w-8 rounded-full flex items-center justify-center text-white font-semibold text-sm"
          style={{ backgroundColor: agent.color || '#6b7280' }}
        >
          {agent?.name?.charAt(0) || '?'}
        </div>
        <div className="flex-1">
          <div className="flex items-center space-x-2">
            <span className="text-sm font-medium text-white">{agent?.name || 'Unknown Agent'}</span>
            <span className="text-xs text-gray-400">{message.timestamp}</span>
          </div>
          <div
            className="mt-1 rounded-2xl px-4 py-3 text-white border"
            style={{
              backgroundColor: `${agent.color || '#6b7280'}20`,
              borderColor: `${agent.color || '#6b7280'}40`,
            }}
          >
            <p className="text-sm whitespace-pre-wrap">{message.content}</p>
          </div>
        </div>
      </div>
    );
  }

  return null;
}

// User Input Component
interface UserInputProps {
  currentInput: string;
  onInputChange: (input: string) => void;
  onSendMessage: () => void;
  onMentionAgent: (agentId: string) => void;
  agents: DemoAgent[];
  isDisabled: boolean;
}

function UserInput({
  currentInput,
  onInputChange,
  onSendMessage,
  onMentionAgent,
  agents,
  isDisabled,
}: UserInputProps) {
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      onSendMessage();
    }
  };

  return (
    <div className="space-y-3">
      <div className="flex flex-wrap gap-2">
        {agents.map((agent) => (
          <button
            key={agent.id}
            onClick={() => onMentionAgent(agent.id)}
            disabled={isDisabled}
            className="inline-flex items-center rounded-full px-3 py-1.5 text-xs font-medium text-white/80 hover:text-white hover:bg-white/10 transition-colors disabled:opacity-50"
            style={{ borderColor: agent.color, borderWidth: 1 }}
          >
            @{agent.name.toLowerCase().replace(/\s+/g, '')}
          </button>
        ))}
      </div>
      <div className="flex space-x-3">
        <textarea
          value={currentInput}
          onChange={(e) => onInputChange(e.target.value)}
          onKeyDown={handleKeyPress}
          placeholder="Type your message to the roundtable..."
          disabled={isDisabled}
          className="flex-1 resize-none rounded-xl bg-gray-800 px-4 py-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
          rows={3}
        />
        <button
          onClick={onSendMessage}
          disabled={isDisabled || !currentInput.trim()}
          className="rounded-xl bg-blue-600 px-6 py-3 font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        >
          Send
        </button>
      </div>
    </div>
  );
}

// Main Component
export default function RoundtableInterface2(props: Props) {
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  const activeAgentId = undefined; // TODO: Add logic to determine active agent from demo step

  useEffect(() => {
    if (scrollAreaRef.current) {
      scrollAreaRef.current.scrollTop = scrollAreaRef.current.scrollHeight;
    }
  }, [props.messages]);

  return (
    <div className="relative flex h-[85vh] w-full max-w-4xl mx-auto flex-col rounded-2xl border border-white/10 bg-gray-900/90 shadow-2xl shadow-black/50 backdrop-blur-xl">
      {/* Header with Agent Circle */}
      <header className="relative flex flex-shrink-0 items-center justify-center p-6">
        <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2">
          <div className="flex h-16 w-16 items-center justify-center rounded-full border border-white/10 bg-gray-800/50">
            <div className="h-8 w-8 rounded-full bg-gradient-to-br from-blue-500 to-purple-600" />
          </div>
        </div>
        <div className="flex w-full items-center justify-center">
          {props.agents.map((agent, index) => (
            <AgentAvatar
              key={agent.id}
              agent={agent}
              isActive={activeAgentId === agent.id}
              position={index}
              onAvatarClick={props.onAgentFocusedChatOpen || (() => {})}
              onNameClick={props.onAgentModalOpen || (() => {})}
            />
          ))}
        </div>
      </header>

      {/* Messages Area */}
      <div ref={scrollAreaRef} className="flex-grow overflow-y-auto p-6 scroll-smooth">
        <div className="flex flex-col space-y-6">
          {props.messages.map((msg) => (
            <ChatMessage key={msg.id} message={msg} agents={props.agents} />
          ))}
          {activeAgentId && (
            <div className="flex items-center space-x-3">
              <AgentAvatar
                agent={props.agents.find((a) => a.id === activeAgentId)!}
                isActive={true}
                isThinking={true}
                onAvatarClick={() => {}}
                onNameClick={() => {}}
              />
              <div className="flex items-center space-x-1">
                <span className="h-1.5 w-1.5 animate-pulse rounded-full bg-white/50 [animation-delay:-0.3s]"></span>
                <span className="h-1.5 w-1.5 animate-pulse rounded-full bg-white/50 [animation-delay:-0.15s]"></span>
                <span className="h-1.5 w-1.5 animate-pulse rounded-full bg-white/50"></span>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* User Input Footer */}
      <footer className="flex-shrink-0 p-4">
        <UserInput
          currentInput={props.currentUserInput}
          onInputChange={props.onUserInputChange}
          onSendMessage={props.onSendMessage}
          onMentionAgent={props.onMentionAgent}
          agents={props.agents}
          isDisabled={props.isInputDisabled}
        />
      </footer>

      {/* Agent Configuration Modal */}
      {props.openAgentModal && (
        <AgentModal
          agent={props.agents.find((a) => a.id === props.openAgentModal)}
          onClose={props.onAgentModalClose || (() => {})}
        />
      )}

      {/* Focused Agent Chat Modal */}
      {props.openFocusedChat && (
        <FocusedAgentChatModal
          agents={props.agents}
          currentAgentId={props.openFocusedChat}
          conversationHistory={props.demoState?.conversationHistory || []}
          onClose={props.onAgentFocusedChatClose || (() => {})}
          onNavigateAgent={props.onNavigateAgent || (() => {})}
        />
      )}
    </div>
  );
}

// Agent Configuration Modal Component
interface AgentModalProps {
  agent?: DemoAgent;
  onClose: () => void;
}

function AgentModal({ agent, onClose }: AgentModalProps) {
  if (!agent) return null;
  const agentColor = agent.color || '#6b7280';

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[80vh] overflow-y-auto">
        <div className="p-6">
          {/* Agent Header */}
          <div className="flex items-center gap-4 mb-6">
            <div
              className="w-16 h-16 rounded-full flex items-center justify-center text-white text-xl font-bold"
              style={{ backgroundColor: agentColor }}
            >
              {agent.name.charAt(0)}
            </div>
            <div>
              <h2 className="text-xl font-semibold text-gray-900">{agent.name}</h2>
              <p className="text-sm text-gray-500">Agent Details</p>
            </div>
          </div>
          {/* Agent Info */}
          <div className="space-y-4">
            <div>
              <h3 className="text-sm font-medium text-gray-700 mb-2">Agent ID</h3>
              <p className="text-sm text-gray-600 font-mono bg-gray-50 p-2 rounded">{agent.id}</p>
            </div>
            <div>
              <h3 className="text-sm font-medium text-gray-700 mb-2">System Prompt</h3>
              <p className="text-sm text-gray-600 bg-gray-50 p-3 rounded leading-relaxed">
                {agent.systemPrompt}
              </p>
            </div>
          </div>
          {/* Close Button */}
          <div className="mt-6 flex justify-end">
            <button
              onClick={onClose}
              className="px-4 py-2 bg-gray-600 text-white text-sm font-medium rounded-md hover:bg-gray-700 transition-colors"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

// Focused Agent Chat Modal Component
interface FocusedAgentChatModalProps {
  agents: DemoAgent[];
  currentAgentId: string;
  conversationHistory: ConversationTurn[];
  onClose: () => void;
  onNavigateAgent: (agentId: string) => void;
}

function FocusedAgentChatModal({
  agents,
  currentAgentId,
  conversationHistory,
  onClose,
  onNavigateAgent,
}: FocusedAgentChatModalProps) {
  const currentAgent = agents.find((a) => a.id === currentAgentId);
  if (!currentAgent) return null;

  const currentAgentIndex = agents.findIndex((a) => a.id === currentAgentId);
  const canGoPrevious = currentAgentIndex > 0;
  const canGoNext = currentAgentIndex < agents.length - 1;

  const handlePrevious = () => {
    if (canGoPrevious) {
      onNavigateAgent(agents[currentAgentIndex - 1].id);
    }
  };

  const handleNext = () => {
    if (canGoNext) {
      onNavigateAgent(agents[currentAgentIndex + 1].id);
    }
  };

  // Get conversation from this agent's perspective (only messages involving them)
  const agentConversation = conversationHistory.filter(
    (turn) =>
      // Show agent's own messages
      turn.author === currentAgentId ||
      // Show user messages that mention this agent
      (turn.author === 'user' && turn.mentionedAgents?.includes(currentAgentId)),
  );

  const agentColor = currentAgent.color || '#6b7280';

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] h-[90vh] flex flex-col">
        {/* Header with navigation */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200">
          <button
            onClick={handlePrevious}
            disabled={!canGoPrevious}
            className="p-2 rounded-md hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            â† Previous Agent
          </button>
          <div className="flex items-center gap-3">
            <div
              className="w-8 h-8 rounded-full flex items-center justify-center text-white text-sm font-bold"
              style={{ backgroundColor: agentColor }}
            >
              {currentAgent.name.charAt(0)}
            </div>
            <h2 className="text-xl font-semibold text-gray-900">{currentAgent.name}</h2>
          </div>
          <button
            onClick={handleNext}
            disabled={!canGoNext}
            className="p-2 rounded-md hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Next Agent â†’
          </button>
        </div>
        {/* Conversation Area */}
        <div className="flex-1 p-4 overflow-y-auto space-y-3 min-h-0">
          {agentConversation.length === 0 ? (
            <div className="text-center text-gray-500 py-8">
              <div
                className="w-12 h-12 rounded-full flex items-center justify-center text-white text-lg font-bold mx-auto mb-3"
                style={{ backgroundColor: agentColor }}
              >
                {currentAgent.name.charAt(0)}
              </div>
              <p className="text-sm">No messages yet with {currentAgent.name}</p>
              <p className="text-xs text-gray-400 mt-1">
                Mention @{currentAgent.name.toLowerCase().replace(/\s+/g, '')} to start a
                conversation
              </p>
            </div>
          ) : (
            agentConversation.map((turn) => (
              <div key={turn.id} className="space-y-2">
                <div className={`flex gap-3 ${turn.author === 'user' ? 'flex-row-reverse' : ''}`}>
                  <div className="flex-1">
                    <div
                      className={`inline-block p-3 rounded-lg max-w-[80%] ${
                        turn.author === 'user' ? 'bg-gray-600 text-white ml-auto' : 'text-white'
                      }`}
                      style={turn.author !== 'user' ? { backgroundColor: agentColor } : {}}
                    >
                      {turn.content}
                    </div>
                    <p
                      className={`text-xs text-gray-500 mt-1 ${turn.author === 'user' ? 'text-right' : ''}`}
                    >
                      {new Date(turn.timestamp).toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit',
                      })}
                    </p>
                  </div>
                </div>
              </div>
            ))
          )}
        </div>
        {/* Input Area */}
        <div className="p-4 border-t border-gray-200">
          <div className="flex gap-3">
            <input
              type="text"
              placeholder={`Send a message to ${currentAgent.name}...`}
              className="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            <button className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
              Send
            </button>
          </div>
        </div>
        {/* Close Button */}
        <button
          onClick={onClose}
          className="absolute top-4 right-4 w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 bg-white rounded-full shadow-md hover:shadow-lg transition-all"
        >
          âœ•
        </button>
      </div>
    </div>
  );
}


===== FILE: apps/chat/src/components/roundtable/types.ts =====

// Component types for the Roundtable Interface
// These define the exact interfaces that v0 will implement

export { type RoundtableInterfaceProps } from '../../lib/types/roundtable';

// Re-export related types for component use
export type {
  Agent,
  ConversationTurn,
  AgentMention,
  RoundtableState,
} from '../../lib/types/roundtable';


===== FILE: apps/chat/src/devapi/mockArtifacts.ts =====

import type { Artifact } from '@/types/chat'

export const MOCK_ARTIFACTS: Artifact[] = [
  { id: 'a_doc_1', name: 'Design Spec.pdf', type: 'doc' },
  { id: 'a_code_1', name: 'api/client.ts', type: 'code' },
  { id: 'a_data_1', name: 'metrics.csv', type: 'data' },
]

export const MOCK_ARTIFACTS_MAP: Record<string, Artifact> = Object.fromEntries(
  MOCK_ARTIFACTS.map((a) => [a.id, a]),
)



===== FILE: apps/chat/src/devapi/mockStream.ts =====

// Tiny mock streaming fallback for local dev.
// Returns a stream plus provenance metadata to simulate server "meta".
import type { Capability, MessageProvenance } from '@/types/chat';

async function* buildStream(
  target: string,
  totalChunks: number,
): AsyncGenerator<string, void, void> {
  const len = target.length;
  const avg = Math.max(1, Math.floor(len / totalChunks));
  let i = 0;
  while (i < len) {
    const jitter = Math.floor(Math.random() * Math.max(1, Math.floor(avg / 2)));
    const size = Math.min(len - i, avg + jitter);
    const chunk = target.slice(i, i + size);
    i += size;
    yield chunk;
    const delay = 1500 + Math.random() * 500;
    const step = delay / totalChunks;
    await new Promise((r) => setTimeout(r, step));
  }
}

export function mockStream(
  text: string,
  capability: Capability,
): { stream: AsyncGenerator<string, void, void>; meta: MessageProvenance } {
  const words = text.split(/\s+/).filter(Boolean);
  const repeat = Math.min(6, Math.max(3, Math.floor(words.length / 5)));
  const totalChunks = Math.max(10, Math.min(20, words.length + repeat));

  const base = `${text}\n\nSure â€” here's a thought: `;
  const target = (base + ' ' + words.concat(words.slice(0, repeat)).join(' ') + '.').trim();

  const brandByCap: Record<Capability, string> = {
    fast: 'GPT-5 mini',
    smart: 'Claude Sonnet 4',
    deep: 'GPT-5',
    'deep-thinking': 'GPT-5 Thinking',
  };

  const whyByCap: Record<Capability, string> = {
    fast: 'Quick response for low-latency ask',
    smart: 'Balanced cost vs. quality',
    deep: 'Complex reasoning and longer context',
    'deep-thinking': 'Multi-step reasoning prioritized',
  };

  const tokensIn = Math.max(1, Math.round(text.length / 4));
  const tokensOut = Math.max(8, Math.round(target.length / 5));
  const latencyMs = 1500 + Math.round(Math.random() * 500);

  const meta: MessageProvenance = {
    capability,
    brandHint: brandByCap[capability],
    whyChosen: whyByCap[capability],
    tokensIn,
    tokensOut,
    latencyMs,
  };

  const stream = buildStream(target, totalChunks);
  return { stream, meta };
}

export default { mockStream };


===== FILE: apps/chat/src/devdata/thread.sample.json =====

[
  {
    "id": "m1",
    "role": "system",
    "text": "Welcome to Liminal Chat. This is a read-only demo thread.",
    "ts": 1710000000000
  },
  {
    "id": "m2",
    "role": "user",
    "text": "Hey there! Can you help me summarize a TypeScript function?",
    "ts": 1710000005000
  },
  {
    "id": "m3",
    "role": "assistant",
    "text": "Sure. Paste the function and I will explain it step by step.",
    "ts": 1710000010000
  },
  {
    "id": "m4",
    "role": "user",
    "text": "```ts\nfunction add(a: number, b: number) {\n  return a + b;\n}\n```\nWhat does it do?",
    "ts": 1710000012000
  },
  {
    "id": "m5",
    "role": "assistant",
    "text": "It takes two numbers and returns their sum. Types enforce that only numbers are accepted.",
    "ts": 1710000017000
  },
  { "id": "m6", "role": "user", "text": "Great. What about edge cases?", "ts": 1710000020000 },
  {
    "id": "m7",
    "role": "assistant",
    "text": "For numbers, there are no special cases here beyond JavaScript number behavior (e.g., Infinity, NaN).",
    "ts": 1710000025000
  },
  { "id": "m8", "role": "user", "text": "Can you show a usage example?", "ts": 1710000030000 },
  {
    "id": "m9",
    "role": "assistant",
    "text": "```ts\nconst result = add(2, 3);\nconsole.log(result); // 5\n```",
    "ts": 1710000033000
  },
  {
    "id": "m10",
    "role": "assistant",
    "text": "You can also rely on type inference in most call sites.",
    "ts": 1710000036000
  },
  {
    "id": "m11",
    "role": "user",
    "text": "Understood. How do I write a test?",
    "ts": 1710000040000
  },
  {
    "id": "m12",
    "role": "assistant",
    "text": "```ts\nimport { describe, it, expect } from 'vitest';\n\ndescribe('add', () => {\n  it('adds two numbers', () => {\n    expect(add(2, 3)).toBe(5);\n  });\n});\n```",
    "ts": 1710000044000
  },
  {
    "id": "m13",
    "role": "user",
    "text": "Nice. What coding style should I follow?",
    "ts": 1710000048000
  },
  {
    "id": "m14",
    "role": "assistant",
    "text": "Prefer small functions, descriptive names, and TypeScript strict mode. Format with Prettier.",
    "ts": 1710000052000
  },
  { "id": "m15", "role": "user", "text": "How do I handle errors?", "ts": 1710000056000 },
  {
    "id": "m16",
    "role": "assistant",
    "text": "Use `try/catch` around risky code and surface clear error messages to the UI.",
    "ts": 1710000060000
  },
  {
    "id": "m17",
    "role": "user",
    "text": "Thanks!\n\nOne more: Show a code fence followed by text.",
    "ts": 1710000064000
  },
  {
    "id": "m18",
    "role": "assistant",
    "text": "```bash\n# install deps\npnpm i\n```\nThen run `pnpm dev:start`.",
    "ts": 1710000068000
  },
  { "id": "m19", "role": "user", "text": "Perfect. That covers it.", "ts": 1710000072000 },
  {
    "id": "m20",
    "role": "assistant",
    "text": "Glad to help! Scroll to review the full thread.",
    "ts": 1710000076000
  }
]


===== FILE: apps/chat/src/hooks/useChatStream.ts =====

import { useCallback, useRef, useState } from 'react';
import type { ChatMessage, StreamStatus, Capability, MessageProvenance } from '../types/chat';

type SendOptions = {
  onToken?: (chunk: string) => void;
};

export function useChatStream(threadId: string, capability: Capability) {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [status, setStatus] = useState<StreamStatus>('idle');
  const [error, setError] = useState<string | undefined>(undefined);
  const abortRef = useRef<AbortController | null>(null);
  const pendingAssistantId = useRef<string | null>(null);
  const lastUserId = useRef<string | null>(null);
  const lastPayload = useRef<{ text: string } | null>(null);

  const appendAssistant = useCallback((id: string, chunk: string) => {
    setMessages((prev) => prev.map((m) => (m.id === id ? { ...m, text: m.text + chunk } : m)));
  }, []);

  const addMessage = useCallback((m: ChatMessage) => {
    setMessages((prev) => [...prev, m]);
  }, []);

  const startAssistant = useCallback(() => {
    const id = `a_${Date.now()}`;
    pendingAssistantId.current = id;
    addMessage({
      id,
      threadId,
      role: 'assistant',
      text: '',
      ts: Date.now(),
      pending: true,
      metadata: {},
    });
    return id;
  }, [addMessage, threadId]);

  const finalizeAssistant = useCallback(() => {
    const id = pendingAssistantId.current;
    if (!id) return;
    setMessages((prev) => prev.map((m) => (m.id === id ? { ...m, pending: false } : m)));
    pendingAssistantId.current = null;
  }, []);

  const send = useCallback(
    async (text: string, opts?: SendOptions & { artifactIds?: string[] }) => {
      setError(undefined);
      setStatus('sending');
      lastPayload.current = { text };

      const userId = `u_${Date.now()}`;
      lastUserId.current = userId;
      addMessage({
        id: userId,
        threadId,
        role: 'user',
        text,
        ts: Date.now(),
        metadata: { artifactIds: opts?.artifactIds ?? [] },
      });

      const controller = new AbortController();
      abortRef.current = controller;

      let stream: AsyncGenerator<string, void, void> | null = null;
      let metaFromServer: MessageProvenance | null = null;
      const startedAt = Date.now();
      try {
        // Try real endpoint using fetch + ReadableStream of SSE
        const res = await fetch('/api/chat/stream', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ threadId, text, capability, artifactIds: opts?.artifactIds ?? [], rag: null }),
          signal: controller.signal,
        });
        if (!res.ok || !res.body) throw new Error(`HTTP ${res.status}`);

        setStatus('streaming');
        const reader = res.body.getReader();
        let buffer = '';
        stream = (async function* () {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += new TextDecoder().decode(value);
            // naive SSE parse: lines starting with 'data: ' under event: token
            const parts = buffer.split('\n\n');
            buffer = parts.pop() || '';
            for (const part of parts) {
              const lines = part.split('\n');
              let event: string | null = null;
              let data = '';
              for (const ln of lines) {
                if (ln.startsWith('event:')) event = ln.slice(6).trim();
                else if (ln.startsWith('data:')) data += ln.slice(5).trim();
              }
              if (event === 'token') yield data;
              if (event === 'meta') {
                try {
                  const obj = JSON.parse(data);
                  const p = obj && obj.provenance ? obj.provenance : obj;
                  metaFromServer = { capability, ...p } as MessageProvenance;
                } catch {
                  // ignore malformed meta
                }
              }
              if (event === 'error') throw new Error(data || 'stream error');
              if (event === 'done') return;
            }
          }
        })();
      } catch {
        // fallback
        setStatus('streaming');
        const mod = await import('../devapi/mockStream');
        const { stream: mock, meta } = await mod.mockStream(text, capability);
        stream = mock;
        metaFromServer = meta;
      }

      const aId = startAssistant();
      // Attach same artifactIds to assistant for display grouping
      if (opts?.artifactIds && opts.artifactIds.length > 0) {
        setMessages((prev) =>
          prev.map((m) =>
            m.id === aId ? { ...m, metadata: { ...(m.metadata || {}), artifactIds: opts.artifactIds } } : m,
          ),
        );
      }
      if (metaFromServer) {
        setMessages((prev) =>
          prev.map((m) =>
            m.id === aId
              ? { ...m, metadata: { ...(m.metadata || {}), provenance: metaFromServer! } }
              : m,
          ),
        );
      }
      try {
        for await (const chunk of stream!) {
          appendAssistant(aId, chunk);
          opts?.onToken?.(chunk);
        }
        // If we have provenance but no latency, compute roughly
        if (metaFromServer && !metaFromServer.latencyMs) {
          const latency = Date.now() - startedAt;
          setMessages((prev) =>
            prev.map((m) =>
              m.id === aId
                ? {
                    ...m,
                    metadata: {
                      ...(m.metadata || {}),
                      provenance: { ...metaFromServer!, latencyMs: latency },
                    },
                  }
                : m,
            ),
          );
        }
        finalizeAssistant();
        setStatus('idle');
      } catch (e: unknown) {
        setStatus('error');
        setMessages((prev) => prev.map((m) => (m.id === aId ? { ...m, pending: false } : m)));
        const msg = e instanceof Error ? e.message : 'Streaming failed';
        setError(msg);
      }
    },
    [addMessage, appendAssistant, capability, finalizeAssistant, startAssistant, threadId],
  );

  const cancel = useCallback(() => {
    abortRef.current?.abort();
    abortRef.current = null;
    const id = pendingAssistantId.current;
    if (id) {
      setMessages((prev) =>
        prev.map((m) => (m.id === id ? { ...m, pending: false, stopped: true } : m)),
      );
      pendingAssistantId.current = null;
    }
    setStatus('idle');
  }, []);

  const retry = useCallback(() => {
    if (!lastPayload.current) return;
    setStatus('idle');
    void send(lastPayload.current.text);
  }, [send]);

  const onTokenAppended = useCallback(() => {
    // Reserved for external scroll logic if needed
  }, []);

  return { messages, status, error, send, cancel, retry, onTokenAppended } as const;
}

export default useChatStream;


===== FILE: apps/chat/src/hooks/usePanelState.ts =====

import { useState, useEffect, useCallback } from 'react';

type Capability = 'fast' | 'smart' | 'deep' | 'deep-thinking';

interface PanelState {
  leftOpen: boolean;
  rightOpen: boolean;
  wL: number;
  wR: number;
  mode: Capability;
}

const DEFAULT_STATE: PanelState = {
  leftOpen: true,
  rightOpen: true,
  wL: 280,
  wR: 320,
  mode: 'smart',
};

const STORAGE_KEY = 'liminal.ui.panels';

export const usePanelState = () => {
  const [state, setState] = useState<PanelState>(DEFAULT_STATE);

  // Load state from URL params and localStorage on mount
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const stored = localStorage.getItem(STORAGE_KEY);
    const storedState = stored ? JSON.parse(stored) : {};

    const newState: PanelState = {
      leftOpen:
        urlParams.get('left') === 'off' ? false : (storedState.leftOpen ?? DEFAULT_STATE.leftOpen),
      rightOpen:
        urlParams.get('right') === 'off'
          ? false
          : (storedState.rightOpen ?? DEFAULT_STATE.rightOpen),
      wL: Number.parseInt(urlParams.get('wL') || '') || storedState.wL || DEFAULT_STATE.wL,
      wR: Number.parseInt(urlParams.get('wR') || '') || storedState.wR || DEFAULT_STATE.wR,
      mode: (urlParams.get('mode') as Capability) || storedState.mode || DEFAULT_STATE.mode,
    };

    setState(newState);
  }, []);

  // Persist state to URL and localStorage
  const persistState = useCallback((newState: PanelState) => {
    // Update URL
    const url = new URL(window.location.href);
    url.searchParams.set('left', newState.leftOpen ? 'on' : 'off');
    url.searchParams.set('right', newState.rightOpen ? 'on' : 'off');
    url.searchParams.set('wL', newState.wL.toString());
    url.searchParams.set('wR', newState.wR.toString());
    url.searchParams.set('mode', newState.mode);

    window.history.replaceState({}, '', url.toString());

    // Update localStorage
    localStorage.setItem(STORAGE_KEY, JSON.stringify(newState));
  }, []);

  const updateState = useCallback(
    (updates: Partial<PanelState>) => {
      setState((prev) => {
        const newState = { ...prev, ...updates };
        persistState(newState);
        return newState;
      });
    },
    [persistState],
  );

  const onToggleLeft = useCallback(() => {
    updateState({ leftOpen: !state.leftOpen });
  }, [state.leftOpen, updateState]);

  const onToggleRight = useCallback(() => {
    updateState({ rightOpen: !state.rightOpen });
  }, [state.rightOpen, updateState]);

  const onResizeLeft = useCallback(
    (wL: number) => {
      updateState({ wL });
    },
    [updateState],
  );

  const onResizeRight = useCallback(
    (wR: number) => {
      updateState({ wR });
    },
    [updateState],
  );

  const onSelectMode = useCallback(
    (mode: Capability) => {
      updateState({ mode });
    },
    [updateState],
  );

  return {
    state,
    onToggleLeft,
    onToggleRight,
    onResizeLeft,
    onResizeRight,
    onSelectMode,
  };
};


===== FILE: apps/chat/src/hooks/useThreadMessages.ts =====

import { useEffect, useMemo, useState } from 'react';
import type { ChatMessage } from '@/types/chat';
// Prefer Convex if available; otherwise use mock data.
// For this repo, the byThread query may not exist yet, so we default to mock.

// Static mock import keeps things working immediately in dev.
import sample from '@/devdata/thread.sample.json';

export function useThreadMessages(threadId?: string): {
  messages: ChatMessage[];
  isLoading: boolean;
} {
  // In the future, if a Convex query like api.messages.byThread exists,
  // we can switch to it here. For now, rely on the mock data.
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    // Simulate async load for a realistic UX
    const timer = setTimeout(() => {
      try {
        const data = (sample as unknown as ChatMessage[]).slice().sort((a, b) => a.ts - b.ts);
        setMessages(data);
      } finally {
        setLoading(false);
      }
    }, 50);
    return () => clearTimeout(timer);
  }, [threadId]);

  return useMemo(() => ({ messages, isLoading: loading }), [messages, loading]);
}


===== FILE: apps/chat/src/index.css =====

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}


===== FILE: apps/chat/src/lib/auth.ts =====

import { createContext, useContext, useCallback } from 'react';
import { LocalDevAuth } from './local-dev-auth';

export interface AuthState {
  isAuthenticated: boolean;
  isLoading: boolean;
  user: { email: string; id: string } | null;
  token: string | null;
  error: string | null;
  authMode: 'dev' | 'production';
}

export interface AuthActions {
  login: () => Promise<void>;
  logout: () => void;
  getAuthHeaders: () => Promise<Record<string, string>>;
  refreshToken: () => Promise<void>;
}

export type AuthContextType = AuthState & AuthActions;

export const AuthContext = createContext<AuthContextType | null>(null);

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

/**
 * Hook to get auth headers for Convex functions.
 * Automatically handles token refresh in dev mode.
 */
export function useAuthHeaders() {
  const { getAuthHeaders, isAuthenticated } = useAuth();

  return useCallback(async () => {
    if (!isAuthenticated) {
      return {};
    }

    try {
      return await getAuthHeaders();
    } catch (error) {
      console.error('Failed to get auth headers:', error);
      return {};
    }
  }, [getAuthHeaders, isAuthenticated]);
}

/**
 * Creates auth state manager based on environment.
 */
export function createAuthManager(): {
  authMode: 'dev' | 'production';
  devAuth?: LocalDevAuth;
} {
  const authMode = (import.meta.env.VITE_AUTH_MODE || 'production') as 'dev' | 'production';
  // Singleton to avoid multiple instances & cache duplication
  // (module scope variable retained across re-renders / hooks usage)
  if (!(globalThis as Record<string, unknown>).__DEV_LOCAL_AUTH_INSTANCE) {
    // Only create when needed
    if (authMode === 'dev') {
      (globalThis as Record<string, unknown>).__DEV_LOCAL_AUTH_INSTANCE = new LocalDevAuth();
    }
  }
  const devAuth: LocalDevAuth | undefined = (globalThis as Record<string, unknown>)
    .__DEV_LOCAL_AUTH_INSTANCE as LocalDevAuth;
  if (authMode === 'dev') {
    return { authMode, devAuth };
  }
  return { authMode };
}


===== FILE: apps/chat/src/lib/authSync.ts =====

type AuthSyncEvent = { type: 'login' | 'logout' };

let channel: BroadcastChannel | null = null;

export function initAuthSync(onEvent: (e: AuthSyncEvent) => void) {
  if (typeof window === 'undefined' || 'BroadcastChannel' in window === false) return;
  if (!channel) {
    channel = new BroadcastChannel('auth-sync');
    channel.onmessage = (evt) => {
      const data = evt.data as AuthSyncEvent | undefined;
      if (!data) return;
      onEvent(data);
    };
  }
}

export function notifyAuthLogin() {
  if (channel) channel.postMessage({ type: 'login' } as AuthSyncEvent);
}

export function notifyAuthLogout() {
  if (channel) channel.postMessage({ type: 'logout' } as AuthSyncEvent);
}

// Reconnect banner store (minimal, avoids extra deps)
let reconnectListeners: Array<(v: boolean) => void> = [];
let reconnectVisible = false;

export function setReconnectVisible(v: boolean) {
  reconnectVisible = v;
  for (const fn of reconnectListeners) fn(v);
}

export function onReconnectVisible(fn: (v: boolean) => void) {
  reconnectListeners.push(fn);
  // initial
  fn(reconnectVisible);
  return () => {
    reconnectListeners = reconnectListeners.filter((f) => f !== fn);
  };
}


===== FILE: apps/chat/src/lib/convex.ts =====

import { ConvexReactClient } from 'convex/react';

// Try window override â†’ Vercel env â†’ fallback to staging Convex URL
const convexUrl =
  (typeof window !== 'undefined' && (window as { __CONVEX_URL?: string }).__CONVEX_URL) ||
  import.meta.env.VITE_CONVEX_URL ||
  'https://peaceful-cassowary-494.convex.cloud';

export const convex = new ConvexReactClient(convexUrl);


===== FILE: apps/chat/src/lib/demo-system/demo-engine.ts =====

// Demo Engine - Pure client-side state calculation
// No backend dependencies - everything driven from scripted data

import type {
  DemoScript,
  DemoStep,
  RoundtableState,
  ConversationTurn,
  AgentMention,
} from '../types/roundtable';

/**
 * Calculate the current roundtable state from a demo script and step index
 * This is pure state calculation - no side effects, no backend calls
 */
export function calculateRoundtableState(
  script: DemoScript,
  stepIndex: number,
  openAgentModal?: string,
): RoundtableState {
  // Clamp step index to valid range
  const currentStepIndex = Math.max(0, Math.min(stepIndex, script.steps.length - 1));
  const currentStep = script.steps[currentStepIndex];

  // Build conversation history up to current step
  const conversationHistory = buildConversationHistory(script, currentStepIndex);

  // Generate agent mentions for @clicking
  const availableAgentMentions: AgentMention[] = script.agents.map((agent) => ({
    agentId: agent.id,
    agentName: agent.name,
    insertText: `@${agent.name.toLowerCase().replace(/\s+/g, '')}`,
  }));

  // Determine current user input based on step
  const currentUserInput = getCurrentUserInput(currentStep);

  // Determine if we're waiting for user input
  const awaitingUserInput = currentStep.state === 'composing-message';

  return {
    agents: script.agents,
    conversationHistory,
    currentUserInput,
    awaitingUserInput,
    availableAgentMentions,
    openAgentModal,
    currentStepTitle: currentStep.title,
    currentStepIndex,
    totalSteps: script.steps.length,
  };
}

/**
 * Build the full conversation history up to the specified step
 */
function buildConversationHistory(script: DemoScript, upToStepIndex: number): ConversationTurn[] {
  const history: ConversationTurn[] = [];
  let turnId = 1;

  for (let i = 0; i <= upToStepIndex; i++) {
    const step = script.steps[i];
    const timestamp = Date.now() - (script.steps.length - i) * 60000; // Fake timestamps

    // Add user input only when message is first sent (not again when complete)
    if (step.userInput && step.state === 'message-sent') {
      const mentionedAgents = extractMentionedAgents(step.userInput);

      history.push({
        id: `turn-${turnId++}`,
        type: 'user_input',
        timestamp,
        author: 'user',
        content: step.userInput,
        mentionedAgents,
      });
    }

    // Add agent responses only for completed steps
    if (step.state === 'agents-complete') {
      for (const response of step.expectedAgentResponses) {
        if (response.isComplete !== false) {
          history.push({
            id: `turn-${turnId++}`,
            type: 'agent_response',
            timestamp: timestamp + 1000, // Agent responses come after user input
            author: response.agentId,
            content: response.content,
          });
        }
      }
    }
  }

  return history;
}

/**
 * Extract mentioned agent IDs from user input text
 */
function extractMentionedAgents(userInput: string): string[] {
  const mentions = userInput.match(/@\w+/g) || [];
  return mentions.map((mention) => mention.substring(1)); // Remove @ symbol
}

/**
 * Determine current user input based on step state
 */
function getCurrentUserInput(step: DemoStep): string {
  if (step.state === 'composing-message' && step.userInput) {
    return step.userInput; // Show message being composed
  }

  if (step.state === 'message-sent' && step.userInput) {
    return ''; // Message was sent, clear the input box
  }

  if (step.state === 'agents-complete') {
    return ''; // Empty input box, ready for next message
  }

  return ''; // Default empty input box
}

/**
 * Advance to the next step in the demo
 */
export function advanceStep(script: DemoScript, currentStep: number): number {
  return Math.min(currentStep + 1, script.steps.length - 1);
}

/**
 * Go back to the previous step in the demo
 */
export function previousStep(currentStep: number): number {
  return Math.max(currentStep - 1, 0);
}

/**
 * Jump to a specific step (clamped to valid range)
 */
export function jumpToStep(targetStep: number, maxSteps: number): number {
  return Math.max(0, Math.min(targetStep, maxSteps - 1));
}

/**
 * Check if we can advance to next step
 */
export function canAdvanceStep(script: DemoScript, currentStep: number): boolean {
  return currentStep < script.steps.length - 1;
}

/**
 * Check if we can go back to previous step
 */
export function canGoBackStep(currentStep: number): boolean {
  return currentStep > 0;
}

/**
 * Insert an agent mention into user input at cursor position
 * This simulates clicking @agent buttons
 */
export function insertAgentMention(
  currentInput: string,
  cursorPosition: number,
  mention: AgentMention,
): { newInput: string; newCursorPosition: number } {
  const before = currentInput.substring(0, cursorPosition);
  const after = currentInput.substring(cursorPosition);

  // Add space before mention if needed
  const needsSpaceBefore = before.length > 0 && !before.endsWith(' ');
  const prefix = needsSpaceBefore ? ' ' : '';

  // Add space after mention
  const suffix = ' ';

  const insertText = `${prefix}${mention.insertText}${suffix}`;
  const newInput = before + insertText + after;
  const newCursorPosition = cursorPosition + insertText.length;

  return { newInput, newCursorPosition };
}


===== FILE: apps/chat/src/lib/demo-system/demo-hooks.ts =====

// React Hooks for Demo State Management
// Provides clean interface for components to interact with demo system

import { useState, useCallback, useMemo } from 'react';
import type { DemoControls, RoundtableState } from '../types/roundtable';
import { getDemoScript } from './demo-scripts';
import {
  calculateRoundtableState,
  advanceStep,
  previousStep,
  jumpToStep,
  canAdvanceStep,
  canGoBackStep,
  insertAgentMention,
} from './demo-engine';

/**
 * Main hook for demo controls
 * Provides complete demo state management with navigation and interaction handlers
 */
export function useDemoControls(scriptId: string): DemoControls {
  const script = getDemoScript(scriptId);
  const [currentStep, setCurrentStep] = useState(0);
  const [openAgentModal, setOpenAgentModal] = useState<string | undefined>();
  const [openFocusedChat, setOpenFocusedChat] = useState<string | undefined>();
  const [userInputOverride, setUserInputOverride] = useState<string>('');

  // Calculate current roundtable state
  const currentState = useMemo(() => {
    const state = calculateRoundtableState(script, currentStep, openAgentModal);

    // Add focused chat state
    const stateWithFocusedChat = { ...state, openFocusedChat };

    // Apply user input override if present
    if (userInputOverride) {
      return { ...stateWithFocusedChat, currentUserInput: userInputOverride };
    }

    return stateWithFocusedChat;
  }, [script, currentStep, openAgentModal, openFocusedChat, userInputOverride]);

  // Navigation handlers
  const nextStep = useCallback(() => {
    setCurrentStep((current) => advanceStep(script, current));
    setUserInputOverride(''); // Clear override when navigating
  }, [script]);

  const prevStep = useCallback(() => {
    setCurrentStep((current) => previousStep(current));
    setUserInputOverride(''); // Clear override when navigating
  }, []);

  const jumpToStepHandler = useCallback(
    (stepIndex: number) => {
      setCurrentStep(jumpToStep(stepIndex, script.steps.length));
      setUserInputOverride(''); // Clear override when navigating
    },
    [script.steps.length],
  );

  const resetDemo = useCallback(() => {
    setCurrentStep(0);
    setOpenAgentModal(undefined);
    setUserInputOverride('');
  }, []);

  // UI interaction handlers
  const handleUserInput = useCallback((input: string) => {
    setUserInputOverride(input);
  }, []);

  const handleAgentMention = useCallback(
    (agentId: string) => {
      const agent = script.agents.find((a) => a.id === agentId);
      if (!agent) return;

      const mention = {
        agentId: agent.id,
        agentName: agent.name,
        insertText: `@${agent.name.toLowerCase().replace(/\s+/g, '')}`,
      };

      // Insert mention at end of current input
      // In a real implementation, this would respect cursor position
      const currentInput = userInputOverride || currentState.currentUserInput;
      const result = insertAgentMention(currentInput, currentInput.length, mention);
      setUserInputOverride(result.newInput);
    },
    [script.agents, userInputOverride, currentState.currentUserInput],
  );

  const handleAgentModalOpen = useCallback((agentId: string) => {
    setOpenAgentModal(agentId);
  }, []);

  const handleAgentModalClose = useCallback(() => {
    setOpenAgentModal(undefined);
  }, []);

  const handleAgentFocusedChatOpen = useCallback((agentId: string) => {
    setOpenFocusedChat(agentId);
  }, []);

  const handleAgentFocusedChatClose = useCallback(() => {
    setOpenFocusedChat(undefined);
  }, []);

  return {
    currentState,
    currentStep,
    totalSteps: script.steps.length,
    script,
    nextStep,
    prevStep,
    jumpToStep: jumpToStepHandler,
    resetDemo,
    handleUserInput,
    handleAgentMention,
    handleAgentModalOpen,
    handleAgentModalClose,
    handleAgentFocusedChatOpen,
    handleAgentFocusedChatClose,
  };
}

/**
 * Simple hook that just returns the current roundtable state
 * Useful for components that only need to display state without controls
 */
export function useDemoState(scriptId: string, stepIndex?: number): RoundtableState {
  const script = getDemoScript(scriptId);
  const effectiveStep = stepIndex ?? 0;

  return useMemo(() => {
    return calculateRoundtableState(script, effectiveStep);
  }, [script, effectiveStep]);
}

/**
 * Hook for demo navigation utilities
 * Provides info about navigation state without managing it
 */
export function useDemoNavigation(scriptId: string, currentStep: number) {
  const script = getDemoScript(scriptId);

  return useMemo(
    () => ({
      canGoNext: canAdvanceStep(script, currentStep),
      canGoPrevious: canGoBackStep(currentStep),
      stepTitle: script.steps[currentStep]?.title || 'Unknown Step',
      stepProgress: `${currentStep + 1} / ${script.steps.length}`,
      isFirstStep: currentStep === 0,
      isLastStep: currentStep === script.steps.length - 1,
    }),
    [script, currentStep],
  );
}

/**
 * Hook for script selection and management
 */
export function useScriptSelection() {
  const [selectedScriptId, setSelectedScriptId] = useState('character-development');

  const selectScript = useCallback((scriptId: string) => {
    setSelectedScriptId(scriptId);
  }, []);

  const selectedScript = getDemoScript(selectedScriptId);

  return {
    selectedScriptId,
    selectedScript,
    selectScript,
  };
}

/**
 * Debug hook for development
 * Exposes internal state for debugging components
 */
export function useDemoDebug(scriptId: string, currentStep: number) {
  const script = getDemoScript(scriptId);
  const state = calculateRoundtableState(script, currentStep);

  return {
    script,
    currentStep,
    state,
    stepData: script.steps[currentStep],
    conversationLength: state.conversationHistory.length,
    availableMentions: state.availableAgentMentions.length,
  };
}


===== FILE: apps/chat/src/lib/demo-system/demo-scripts.ts =====

// Demo Scripts - Predefined conversation scenarios
// These showcase the roundtable primitive across different domains

import type { DemoScript } from '../types/roundtable';

/**
 * Character Development Demo - Creative Writing Scenario
 * Shows how multiple agents can collaborate on character development
 */
export const characterDevelopmentScript: DemoScript = {
  id: 'character-development',
  title: 'Character Development Session',
  description: 'Three agents collaborate to develop a detective character for a noir mystery',
  agents: [
    {
      id: 'supportive',
      name: 'Supportive Editor',
      systemPrompt:
        'You encourage ideas and build on them constructively. You find the strengths in concepts and help develop them further.',
      color: '#10b981', // emerald
    },
    {
      id: 'critical',
      name: 'Critical Reviewer',
      systemPrompt:
        'You identify potential problems and inconsistencies. You ask tough questions to strengthen the work.',
      color: '#f59e0b', // amber
    },
    {
      id: 'creative',
      name: 'Creative Brainstormer',
      systemPrompt:
        'You generate wild ideas and unexpected connections. You push creative boundaries and suggest alternatives.',
      color: '#8b5cf6', // violet
    },
  ],
  steps: [
    {
      id: 'step-1-composing',
      title: 'User introduces character concept',
      userInput:
        '@supportive @critical what do you think of Sarah as a detective who secretly uses magic in 1920s Chicago?',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-1-sent',
      title: 'User message sent - agents responding',
      userInput:
        '@supportive @critical what do you think of Sarah as a detective who secretly uses magic in 1920s Chicago?',
      expectedAgentResponses: [
        {
          agentId: 'supportive',
          content:
            'I love the dual identity aspect! A detective who uses magic gives us rich internal conflict - she has to solve crimes while hiding her greatest asset. The 1920s setting is perfect for exploring themes of hidden power and social constraints.',
          isComplete: true,
        },
        {
          agentId: 'critical',
          content:
            'Interesting premise, but we need to be careful about the magic system. How does her magic work? Why is it secret? If magic exists, why isn\'t it more widespread? These questions will determine if the story feels grounded or falls into "magic solves everything" territory.',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-1-complete',
      title: 'Agents finished responding',
      userInput:
        '@supportive @critical what do you think of Sarah as a detective who secretly uses magic in 1920s Chicago?',
      expectedAgentResponses: [
        {
          agentId: 'supportive',
          content:
            'I love the dual identity aspect! A detective who uses magic gives us rich internal conflict - she has to solve crimes while hiding her greatest asset. The 1920s setting is perfect for exploring themes of hidden power and social constraints.',
          isComplete: true,
        },
        {
          agentId: 'critical',
          content:
            'Interesting premise, but we need to be careful about the magic system. How does her magic work? Why is it secret? If magic exists, why isn\'t it more widespread? These questions will determine if the story feels grounded or falls into "magic solves everything" territory.',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-2-composing',
      title: 'User asks for creative expansion',
      userInput:
        '@creative what kind of magic should Sarah have? Something that helps with detective work but creates complications?',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-2-sent',
      title: 'User message sent - creative agent responding',
      userInput:
        '@creative what kind of magic should Sarah have? Something that helps with detective work but creates complications?',
      expectedAgentResponses: [
        {
          agentId: 'creative',
          content:
            "What if Sarah can see the \"emotional residue\" left on objects? She touches a murder weapon and feels the killer's rage, or examines a victim's belongings and experiences their final moments. Perfect for detective work, but imagine the psychological toll - she's constantly experiencing trauma secondhand. And what if she can't turn it off?",
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-2-complete',
      title: 'Creative agent finished responding',
      userInput:
        '@creative what kind of magic should Sarah have? Something that helps with detective work but creates complications?',
      expectedAgentResponses: [
        {
          agentId: 'creative',
          content:
            "What if Sarah can see the \"emotional residue\" left on objects? She touches a murder weapon and feels the killer's rage, or examines a victim's belongings and experiences their final moments. Perfect for detective work, but imagine the psychological toll - she's constantly experiencing trauma secondhand. And what if she can't turn it off?",
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-3-composing',
      title: 'Multi-agent discussion about the magic system',
      userInput:
        '@supportive @critical respond to what @creative suggested about emotional residue',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-3-sent',
      title: 'User message sent - agents responding',
      userInput:
        '@supportive @critical respond to what #creative suggested about emotional residue',
      expectedAgentResponses: [
        {
          agentId: 'supportive',
          content:
            "Brilliant! This creates natural character development - Sarah becomes more empathetic and emotionally scarred with each case. We could show her struggling with the boundary between her emotions and others'. Maybe she starts avoiding personal relationships because she can't trust her own feelings.",
          isComplete: true,
        },
        {
          agentId: 'critical',
          content:
            'The emotional residue concept works, but we need clear limitations. How long does residue last? Can she get false readings from strong emotions unrelated to the crime? What happens if she touches something with overwhelming trauma? We need rules to create meaningful obstacles.',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-3-complete',
      title: 'Agents finished responding',
      userInput:
        '@supportive @critical respond to what @creative suggested about emotional residue',
      expectedAgentResponses: [
        {
          agentId: 'supportive',
          content:
            "Brilliant! This creates natural character development - Sarah becomes more empathetic and emotionally scarred with each case. We could show her struggling with the boundary between her emotions and others'. Maybe she starts avoiding personal relationships because she can't trust her own feelings.",
          isComplete: true,
        },
        {
          agentId: 'critical',
          content:
            'The emotional residue concept works, but we need clear limitations. How long does residue last? Can she get false readings from strong emotions unrelated to the crime? What happens if she touches something with overwhelming trauma? We need rules to create meaningful obstacles.',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-4-composing',
      title: 'User explores character relationships',
      userInput:
        "@supportive how should Sarah's magic affect her relationships with other characters?",
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-4-sent',
      title: 'User message sent - supportive agent responding',
      userInput:
        "@supportive how should Sarah's magic affect her relationships with other characters?",
      expectedAgentResponses: [
        {
          agentId: 'supportive',
          content:
            'Her magic could create fascinating relationship dynamics! She might avoid touching people she cares about, afraid of what she\'ll feel. Or she could become the person everyone confides in because she truly understands their pain. Maybe she has a partner who doesn\'t know about her magic, creating tension when she solves cases with "impossible" insights.',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-4-complete',
      title: 'Supportive agent finished responding',
      userInput:
        "@supportive how should Sarah's magic affect her relationships with other characters?",
      expectedAgentResponses: [
        {
          agentId: 'supportive',
          content:
            'Her magic could create fascinating relationship dynamics! She might avoid touching people she cares about, afraid of what she\'ll feel. Or she could become the person everyone confides in because she truly understands their pain. Maybe she has a partner who doesn\'t know about her magic, creating tension when she solves cases with "impossible" insights.',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-5-composing',
      title: 'User requests creative complications',
      userInput:
        "@creative @critical what if Sarah's magic starts malfunctioning during the story?",
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-5-sent',
      title: 'User message sent - agents responding',
      userInput:
        "@creative @critical what if Sarah's magic starts malfunctioning during the story?",
      expectedAgentResponses: [
        {
          agentId: 'creative',
          content:
            "Oh! What if she starts experiencing emotions from the future instead of the past? She touches evidence and feels the killer's satisfaction about murders that haven't happened yet. Now she's in a race against time, but can't explain how she knows without revealing her secret.",
          isComplete: true,
        },
        {
          agentId: 'critical',
          content:
            "That's a compelling twist, but it changes the story's logic significantly. We'd need to establish why her magic is changing - is it connected to a larger magical threat? Is she being targeted? The malfunction needs to serve the plot, not just create arbitrary obstacles.",
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-5-complete',
      title: 'Agents finished responding',
      userInput:
        "@creative @critical what if Sarah's magic starts malfunctioning during the story?",
      expectedAgentResponses: [
        {
          agentId: 'creative',
          content:
            "Oh! What if she starts experiencing emotions from the future instead of the past? She touches evidence and feels the killer's satisfaction about murders that haven't happened yet. Now she's in a race against time, but can't explain how she knows without revealing her secret.",
          isComplete: true,
        },
        {
          agentId: 'critical',
          content:
            "That's a compelling twist, but it changes the story's logic significantly. We'd need to establish why her magic is changing - is it connected to a larger magical threat? Is she being targeted? The malfunction needs to serve the plot, not just create arbitrary obstacles.",
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
  ],
};

/**
 * Code Review Demo - Technical Collaboration Scenario
 * Shows how agents can review and improve code from different perspectives
 */
export const codeReviewScript: DemoScript = {
  id: 'code-review',
  title: 'Code Review Session',
  description:
    'Technical agents review a React component for security, performance, and best practices',
  agents: [
    {
      id: 'security',
      name: 'Security Auditor',
      systemPrompt:
        'You focus on security vulnerabilities, input validation, and potential attack vectors in code.',
      color: '#dc2626', // red
    },
    {
      id: 'performance',
      name: 'Performance Expert',
      systemPrompt:
        'You analyze code for performance bottlenecks, optimization opportunities, and scalability issues.',
      color: '#2563eb', // blue
    },
    {
      id: 'practices',
      name: 'Best Practices Reviewer',
      systemPrompt:
        'You evaluate code for maintainability, readability, and adherence to coding standards.',
      color: '#059669', // emerald
    },
  ],
  steps: [
    {
      id: 'step-1-composing',
      title: 'User submits code for review',
      userInput:
        '@security @performance @practices please review this user authentication component',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-1-sent',
      title: 'User message sent - agents analyzing code',
      userInput:
        '@security @performance @practices please review this user authentication component',
      expectedAgentResponses: [
        {
          agentId: 'security',
          content:
            'ğŸ” SECURITY ISSUES FOUND:\nâ€¢ No input sanitization on email field\nâ€¢ Password visibility toggle lacks rate limiting\nâ€¢ JWT storage in localStorage vulnerable to XSS\nâ€¢ Missing CSRF protection on login endpoint\nâ€¢ Consider implementing 2FA support',
          isComplete: true,
        },
        {
          agentId: 'performance',
          content:
            'âš¡ PERFORMANCE CONCERNS:\nâ€¢ Re-rendering entire form on every keystroke\nâ€¢ Missing debouncing on validation\nâ€¢ Large bundle size from importing entire lodash\nâ€¢ No lazy loading of validation schema\nâ€¢ Consider using React.memo for form fields',
          isComplete: true,
        },
        {
          agentId: 'practices',
          content:
            'ğŸ“‹ CODE QUALITY NOTES:\nâ€¢ Good TypeScript usage overall\nâ€¢ Consider extracting validation logic to custom hook\nâ€¢ Error handling could be more specific\nâ€¢ Missing accessibility attributes (aria-labels)\nâ€¢ Inconsistent naming convention (camelCase vs kebab-case)',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-1-complete',
      title: 'Agents finished initial review',
      userInput:
        '@security @performance @practices please review this user authentication component',
      expectedAgentResponses: [
        {
          agentId: 'security',
          content:
            'ğŸ” SECURITY ISSUES FOUND:\nâ€¢ No input sanitization on email field\nâ€¢ Password visibility toggle lacks rate limiting\nâ€¢ JWT storage in localStorage vulnerable to XSS\nâ€¢ Missing CSRF protection on login endpoint\nâ€¢ Consider implementing 2FA support',
          isComplete: true,
        },
        {
          agentId: 'performance',
          content:
            'âš¡ PERFORMANCE CONCERNS:\nâ€¢ Re-rendering entire form on every keystroke\nâ€¢ Missing debouncing on validation\nâ€¢ Large bundle size from importing entire lodash\nâ€¢ No lazy loading of validation schema\nâ€¢ Consider using React.memo for form fields',
          isComplete: true,
        },
        {
          agentId: 'practices',
          content:
            'ğŸ“‹ CODE QUALITY NOTES:\nâ€¢ Good TypeScript usage overall\nâ€¢ Consider extracting validation logic to custom hook\nâ€¢ Error handling could be more specific\nâ€¢ Missing accessibility attributes (aria-labels)\nâ€¢ Inconsistent naming convention (camelCase vs kebab-case)',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-2-composing',
      title: 'User asks about security priority',
      userInput: '@security which security issue should I fix first?',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-2-sent',
      title: 'User message sent - security agent responding',
      userInput: '@security which security issue should I fix first?',
      expectedAgentResponses: [
        {
          agentId: 'security',
          content:
            'Priority 1: Move JWT from localStorage to httpOnly cookies immediately. This prevents XSS token theft. Priority 2: Add input sanitization - even with a trusted frontend, always validate server-side. The other issues are important but these two are critical vulnerabilities.',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-2-complete',
      title: 'Security agent finished responding',
      userInput: '@security which security issue should I fix first?',
      expectedAgentResponses: [
        {
          agentId: 'security',
          content:
            'Priority 1: Move JWT from localStorage to httpOnly cookies immediately. This prevents XSS token theft. Priority 2: Add input sanitization - even with a trusted frontend, always validate server-side. The other issues are important but these two are critical vulnerabilities.',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-3-composing',
      title: 'Multi-agent discussion on implementation',
      userInput:
        '@performance @practices how would you implement what #security suggested without hurting performance or code quality?',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-3-sent',
      title: 'User message sent - agents discussing solutions',
      userInput:
        '@performance @practices how would you implement what #security suggested without hurting performance or code quality?',
      expectedAgentResponses: [
        {
          agentId: 'performance',
          content:
            "For JWT cookies: Use SameSite=Strict and Secure flags. For validation: implement schema-based validation with Zod - it's fast and tree-shakeable. Use React Hook Form's resolver for efficient re-renders. This actually improves performance by reducing unnecessary validations.",
          isComplete: true,
        },
        {
          agentId: 'practices',
          content:
            'Create a useSecureAuth hook that encapsulates token management. Use a validation utility that returns consistent error shapes. Consider a FormField component that handles validation, accessibility, and security concerns in one place. This makes security fixes reusable across forms.',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-3-complete',
      title: 'Agents finished discussing solutions',
      userInput:
        '@performance @practices how would you implement what #security suggested without hurting performance or code quality?',
      expectedAgentResponses: [
        {
          agentId: 'performance',
          content:
            "For JWT cookies: Use SameSite=Strict and Secure flags. For validation: implement schema-based validation with Zod - it's fast and tree-shakeable. Use React Hook Form's resolver for efficient re-renders. This actually improves performance by reducing unnecessary validations.",
          isComplete: true,
        },
        {
          agentId: 'practices',
          content:
            'Create a useSecureAuth hook that encapsulates token management. Use a validation utility that returns consistent error shapes. Consider a FormField component that handles validation, accessibility, and security concerns in one place. This makes security fixes reusable across forms.',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-4-composing',
      title: 'User explores performance trade-offs',
      userInput:
        '@performance what performance impacts should I expect from implementing these security changes?',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-4-sent',
      title: 'User message sent - performance expert responding',
      userInput:
        '@performance what performance impacts should I expect from implementing these security changes?',
      expectedAgentResponses: [
        {
          agentId: 'performance',
          content:
            'Surprisingly, most security changes will improve performance. httpOnly cookies reduce client-side storage overhead. Zod validation is faster than manual checks. The main cost is the initial bundle size increase (~5KB for Zod), but you can tree-shake unused validators. Debounced validation actually reduces server calls. Overall: slight initial load increase, better runtime performance.',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-4-complete',
      title: 'Performance expert finished responding',
      userInput:
        '@performance what performance impacts should I expect from implementing these security changes?',
      expectedAgentResponses: [
        {
          agentId: 'performance',
          content:
            'Surprisingly, most security changes will improve performance. httpOnly cookies reduce client-side storage overhead. Zod validation is faster than manual checks. The main cost is the initial bundle size increase (~5KB for Zod), but you can tree-shake unused validators. Debounced validation actually reduces server calls. Overall: slight initial load increase, better runtime performance.',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-5-composing',
      title: 'User requests implementation guidance',
      userInput:
        '@practices @security can you walk me through the step-by-step refactoring process?',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-5-sent',
      title: 'User message sent - agents providing implementation plan',
      userInput:
        '@practices @security can you walk me through the step-by-step refactoring process?',
      expectedAgentResponses: [
        {
          agentId: 'practices',
          content:
            '1. Extract validation schema first (no breaking changes). 2. Create useSecureAuth hook with current logic. 3. Replace localStorage with secure cookie handling. 4. Add input sanitization layer. 5. Update component to use new hook. 6. Add accessibility attributes. 7. Test each step incrementally. This prevents big-bang failures.',
          isComplete: true,
        },
        {
          agentId: 'security',
          content:
            'Critical: Test the cookie implementation in dev first - httpOnly cookies behave differently than localStorage. Set up CSRF tokens before removing localStorage completely. Use a feature flag to switch between old/new auth during transition. Have a rollback plan ready. Security changes should never be rushed.',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-5-complete',
      title: 'Agents finished providing implementation plan',
      userInput:
        '@practices @security can you walk me through the step-by-step refactoring process?',
      expectedAgentResponses: [
        {
          agentId: 'practices',
          content:
            '1. Extract validation schema first (no breaking changes). 2. Create useSecureAuth hook with current logic. 3. Replace localStorage with secure cookie handling. 4. Add input sanitization layer. 5. Update component to use new hook. 6. Add accessibility attributes. 7. Test each step incrementally. This prevents big-bang failures.',
          isComplete: true,
        },
        {
          agentId: 'security',
          content:
            'Critical: Test the cookie implementation in dev first - httpOnly cookies behave differently than localStorage. Set up CSRF tokens before removing localStorage completely. Use a feature flag to switch between old/new auth during transition. Have a rollback plan ready. Security changes should never be rushed.',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
  ],
};

/**
 * Economic Policy Debate Demo - Universal Basic Income Discussion
 * Shows ideological diversity and evidence-based policy analysis
 */
export const economicDebateDemo: DemoScript = {
  id: 'economic-debate',
  title: 'Economic Policy Debate',
  description:
    'Three economists with different perspectives debate Universal Basic Income implementation',
  agents: [
    {
      id: 'market',
      name: 'Free Market Advocate',
      systemPrompt:
        'You analyze policies through the lens of economic efficiency, fiscal responsibility, and market mechanisms.',
      color: '#dc2626', // red
    },
    {
      id: 'progressive',
      name: 'Progressive Economist',
      systemPrompt:
        'You focus on inequality reduction, social justice, and policies that support human dignity and opportunity.',
      color: '#2563eb', // blue
    },
    {
      id: 'data',
      name: 'Data Analyst',
      systemPrompt:
        'You provide empirical evidence, analyze pilot programs, and focus on measurable policy outcomes.',
      color: '#059669', // emerald
    },
  ],
  steps: [
    {
      id: 'step-1-composing',
      title: 'User asks for initial UBI positions',
      userInput:
        '@market @progressive @data What are your initial thoughts on implementing Universal Basic Income in the US?',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-1-sent',
      title: 'User message sent - economists analyzing UBI',
      userInput:
        '@market @progressive @data What are your initial thoughts on implementing Universal Basic Income in the US?',
      expectedAgentResponses: [
        {
          agentId: 'market',
          content:
            'ğŸ›ï¸ FISCAL REALITY CHECK:\nâ€¢ $4+ trillion annual cost for $1000/month to all adults\nâ€¢ Creates massive work disincentives - why work if guaranteed income?\nâ€¢ Crowds out private charity and voluntary cooperation\nâ€¢ Government dependency undermines human agency\nâ€¢ Better solution: reduce barriers to employment, lower taxes, expand opportunity',
          isComplete: true,
        },
        {
          agentId: 'progressive',
          content:
            'âš–ï¸ SOCIAL JUSTICE IMPERATIVE:\nâ€¢ 40 million Americans in poverty despite working multiple jobs\nâ€¢ UBI provides dignity - no means testing, no bureaucratic humiliation\nâ€¢ Enables entrepreneurship by providing safety net for risk-taking\nâ€¢ Recognizes unpaid care work, community service, artistic creation\nâ€¢ Economic security is a human right in the 21st century',
          isComplete: true,
        },
        {
          agentId: 'data',
          content:
            'ğŸ“Š PILOT PROGRAM EVIDENCE:\nâ€¢ Stockton, CA: 78% spent on basic needs, only 1% on "vices"\nâ€¢ Finland: No significant work reduction, improved mental health\nâ€¢ Kenya GiveDirectly: Local economic multiplier effects\nâ€¢ Alaska Permanent Fund: Popular across political spectrum for 40+ years\nâ€¢ Key question: Which design parameters optimize outcomes?',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-1-complete',
      title: 'Economists finished initial positions',
      userInput:
        '@market @progressive @data What are your initial thoughts on implementing Universal Basic Income in the US?',
      expectedAgentResponses: [
        {
          agentId: 'market',
          content:
            'ğŸ›ï¸ FISCAL REALITY CHECK:\nâ€¢ $4+ trillion annual cost for $1000/month to all adults\nâ€¢ Creates massive work disincentives - why work if guaranteed income?\nâ€¢ Crowds out private charity and voluntary cooperation\nâ€¢ Government dependency undermines human agency\nâ€¢ Better solution: reduce barriers to employment, lower taxes, expand opportunity',
          isComplete: true,
        },
        {
          agentId: 'progressive',
          content:
            'âš–ï¸ SOCIAL JUSTICE IMPERATIVE:\nâ€¢ 40 million Americans in poverty despite working multiple jobs\nâ€¢ UBI provides dignity - no means testing, no bureaucratic humiliation\nâ€¢ Enables entrepreneurship by providing safety net for risk-taking\nâ€¢ Recognizes unpaid care work, community service, artistic creation\nâ€¢ Economic security is a human right in the 21st century',
          isComplete: true,
        },
        {
          agentId: 'data',
          content:
            'ğŸ“Š PILOT PROGRAM EVIDENCE:\nâ€¢ Stockton, CA: 78% spent on basic needs, only 1% on "vices"\nâ€¢ Finland: No significant work reduction, improved mental health\nâ€¢ Kenya GiveDirectly: Local economic multiplier effects\nâ€¢ Alaska Permanent Fund: Popular across political spectrum for 40+ years\nâ€¢ Key question: Which design parameters optimize outcomes?',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-2-composing',
      title: 'User challenges market advocate on work incentives',
      userInput:
        '@market what if the work disincentive concern is overblown? What evidence would change your mind?',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-2-sent',
      title: 'User message sent - market advocate responding',
      userInput:
        '@market what if the work disincentive concern is overblown? What evidence would change your mind?',
      expectedAgentResponses: [
        {
          agentId: 'market',
          content:
            "Fair question. I would need to see: 1) Long-term studies (5+ years) showing sustained work participation rates. 2) Evidence that UBI recipients invest in human capital - education, skills, starting businesses. 3) Demonstration that it doesn't create inflation spiral as landlords/retailers raise prices knowing everyone has guaranteed income. 4) Proof it can be funded without destroying economic growth through massive tax increases. Show me those four things consistently across different demographics and regions, and I'll reconsider.",
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-2-complete',
      title: 'Market advocate finished responding',
      userInput:
        '@market what if the work disincentive concern is overblown? What evidence would change your mind?',
      expectedAgentResponses: [
        {
          agentId: 'market',
          content:
            "Fair question. I would need to see: 1) Long-term studies (5+ years) showing sustained work participation rates. 2) Evidence that UBI recipients invest in human capital - education, skills, starting businesses. 3) Demonstration that it doesn't create inflation spiral as landlords/retailers raise prices knowing everyone has guaranteed income. 4) Proof it can be funded without destroying economic growth through massive tax increases. Show me those four things consistently across different demographics and regions, and I'll reconsider.",
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-3-composing',
      title: 'Cross-examination of work incentive concerns',
      userInput:
        '@progressive @data how would you address what #market raised about work incentives and inflation risks?',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-3-sent',
      title: 'User message sent - progressive and data analyst responding',
      userInput:
        '@progressive @data how would you address what #market raised about work incentives and inflation risks?',
      expectedAgentResponses: [
        {
          agentId: 'progressive',
          content:
            'The work incentive argument assumes people only work for survival. But humans work for purpose, social connection, status, self-actualization. UBI could unleash creativity by removing desperation. On inflation: housing costs are driven by supply constraints, not demand. Fix zoning laws. Healthcare costs are driven by monopolistic practices, not spending power. UBI lets people choose work that matters rather than any job that pays bills.',
          isComplete: true,
        },
        {
          agentId: 'data',
          content:
            "Addressing #market's specific criteria: 1) Kenya's 12-year GiveDirectly study shows sustained economic activity. 2) Stockton saw 37% increase in full-time employment during pilot. 3) Alaska's PFD hasn't caused systemic inflation over 40 years. 4) Carbon tax or land value capture could fund it progressively. The evidence exists, but you need to look at the right metrics and timeframes.",
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-3-complete',
      title: 'Progressive and data analyst finished responding',
      userInput:
        '@progressive @data how would you address what #market raised about work incentives and inflation risks?',
      expectedAgentResponses: [
        {
          agentId: 'progressive',
          content:
            'The work incentive argument assumes people only work for survival. But humans work for purpose, social connection, status, self-actualization. UBI could unleash creativity by removing desperation. On inflation: housing costs are driven by supply constraints, not demand. Fix zoning laws. Healthcare costs are driven by monopolistic practices, not spending power. UBI lets people choose work that matters rather than any job that pays bills.',
          isComplete: true,
        },
        {
          agentId: 'data',
          content:
            "Addressing #market's specific criteria: 1) Kenya's 12-year GiveDirectly study shows sustained economic activity. 2) Stockton saw 37% increase in full-time employment during pilot. 3) Alaska's PFD hasn't caused systemic inflation over 40 years. 4) Carbon tax or land value capture could fund it progressively. The evidence exists, but you need to look at the right metrics and timeframes.",
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-4-composing',
      title: 'Deep dive into pilot program data',
      userInput:
        '@data break down the pilot program results - what do they actually tell us about scalability?',
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-4-sent',
      title: 'User message sent - data analyst providing detailed analysis',
      userInput:
        '@data break down the pilot program results - what do they actually tell us about scalability?',
      expectedAgentResponses: [
        {
          agentId: 'data',
          content:
            'Critical limitations: Most pilots are small-scale (hundreds, not millions) and short-term (1-2 years, not decades). General equilibrium effects unknown - what happens when EVERYONE has UBI? However, promising signals: 1) No "laptop and drugs" stereotype - spending remarkably rational. 2) Mental health improvements reduce healthcare costs. 3) Administrative costs 90% lower than means-tested programs. 4) Economic multiplier effects in local communities. Key missing data: labor market responses at scale, political sustainability, interaction with existing programs.',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-4-complete',
      title: 'Data analyst finished detailed analysis',
      userInput:
        '@data break down the pilot program results - what do they actually tell us about scalability?',
      expectedAgentResponses: [
        {
          agentId: 'data',
          content:
            'Critical limitations: Most pilots are small-scale (hundreds, not millions) and short-term (1-2 years, not decades). General equilibrium effects unknown - what happens when EVERYONE has UBI? However, promising signals: 1) No "laptop and drugs" stereotype - spending remarkably rational. 2) Mental health improvements reduce healthcare costs. 3) Administrative costs 90% lower than means-tested programs. 4) Economic multiplier effects in local communities. Key missing data: labor market responses at scale, political sustainability, interaction with existing programs.',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
    {
      id: 'step-5-composing',
      title: 'Synthesis challenge - designing compromise system',
      userInput:
        "@market @progressive @data if you had to design a compromise UBI system that addresses everyone's concerns, what would it look like?",
      expectedAgentResponses: [],
      state: 'composing-message',
    },
    {
      id: 'step-5-sent',
      title: 'User message sent - all economists collaborating on compromise',
      userInput:
        "@market @progressive @data if you had to design a compromise UBI system that addresses everyone's concerns, what would it look like?",
      expectedAgentResponses: [
        {
          agentId: 'market',
          content:
            'Compromise position: Start with Earned Income Tax Credit expansion + Child Tax Credit universalization. Phase in gradually by age cohort (18-25 first). Cap at poverty line, not comfort level. Sunset clause requiring Congressional reauthorization every 10 years. Fund through carbon tax + land value capture, not income taxes. Eliminate overlapping programs to avoid bureaucratic bloat. Include work/education/community service incentives.',
          isComplete: true,
        },
        {
          agentId: 'progressive',
          content:
            "I can accept #market's phase-in approach if: 1) We start with those most vulnerable - caregivers, formerly incarcerated, rural communities hit by automation. 2) No means testing - dignity requires universality. 3) Amount provides genuine choice, not just survival. 4) Include housing vouchers/public options to prevent landlord capture. 5) Strong worker protections so UBI doesn't subsidize exploitative employers.",
          isComplete: true,
        },
        {
          agentId: 'data',
          content:
            'Evidence-based synthesis: Randomized controlled trial with 50,000 participants across urban/rural/diverse demographics. Control for spillover effects. Track for 5 years minimum. Measure: work participation, health outcomes, educational attainment, business creation, community engagement, political attitudes. Use findings to calibrate amount, eligibility, funding mechanism. Let data, not ideology, guide scaling decisions.',
          isComplete: true,
        },
      ],
      state: 'message-sent',
    },
    {
      id: 'step-5-complete',
      title: 'All economists finished collaboration',
      userInput:
        "@market @progressive @data if you had to design a compromise UBI system that addresses everyone's concerns, what would it look like?",
      expectedAgentResponses: [
        {
          agentId: 'market',
          content:
            'Compromise position: Start with Earned Income Tax Credit expansion + Child Tax Credit universalization. Phase in gradually by age cohort (18-25 first). Cap at poverty line, not comfort level. Sunset clause requiring Congressional reauthorization every 10 years. Fund through carbon tax + land value capture, not income taxes. Eliminate overlapping programs to avoid bureaucratic bloat. Include work/education/community service incentives.',
          isComplete: true,
        },
        {
          agentId: 'progressive',
          content:
            "I can accept #market's phase-in approach if: 1) We start with those most vulnerable - caregivers, formerly incarcerated, rural communities hit by automation. 2) No means testing - dignity requires universality. 3) Amount provides genuine choice, not just survival. 4) Include housing vouchers/public options to prevent landlord capture. 5) Strong worker protections so UBI doesn't subsidize exploitative employers.",
          isComplete: true,
        },
        {
          agentId: 'data',
          content:
            'Evidence-based synthesis: Randomized controlled trial with 50,000 participants across urban/rural/diverse demographics. Control for spillover effects. Track for 5 years minimum. Measure: work participation, health outcomes, educational attainment, business creation, community engagement, political attitudes. Use findings to calibrate amount, eligibility, funding mechanism. Let data, not ideology, guide scaling decisions.',
          isComplete: true,
        },
      ],
      state: 'agents-complete',
    },
  ],
};

/**
 * Registry of all available demo scripts
 */
export const demoScripts: Record<string, DemoScript> = {
  'character-development': characterDevelopmentScript,
  'code-review': codeReviewScript,
  'economic-debate': economicDebateDemo,
};

/**
 * Get a demo script by ID with fallback
 */
export function getDemoScript(scriptId: string): DemoScript {
  return demoScripts[scriptId] || characterDevelopmentScript;
}

/**
 * Get list of all available demo scripts
 */
export function getAvailableScripts(): Array<{ id: string; title: string; description: string }> {
  return Object.values(demoScripts).map((script) => ({
    id: script.id,
    title: script.title,
    description: script.description,
  }));
}


===== FILE: apps/chat/src/lib/local-dev-auth.ts =====

interface LocalDevTokenResponse {
  token: string;
  expiresAt: number;
  email: string;
}

/**
 * Authentication client for local development.
 * Retrieves JWT tokens from the local Fastify auth service.
 */
export class LocalDevAuth {
  private baseUrl: string;
  private cachedToken: LocalDevTokenResponse | null = null;

  constructor(baseUrl?: string) {
    this.baseUrl = baseUrl || import.meta.env.VITE_LOCAL_DEV_SERVICE_URL || 'http://127.0.0.1:8081';
  }

  /**
   * Gets a valid access token from the local dev service.
   * Uses cached token if still valid.
   */
  async getValidToken(): Promise<string> {
    // Check if we have a valid cached token
    if (this.cachedToken && Date.now() < this.cachedToken.expiresAt) {
      return this.cachedToken.token;
    }

    try {
      const response = await fetch(`${this.baseUrl}/auth/token`, {
        method: 'POST',
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(`Failed to get token: ${error.error || response.statusText}`);
      }

      const data: LocalDevTokenResponse = await response.json();
      this.cachedToken = data;
      return data.token;
    } catch (error) {
      if (error instanceof TypeError && error.message.includes('fetch failed')) {
        throw new Error(
          `Local dev service not running at ${this.baseUrl}. ` +
            'Please run: npm run dev:start in apps/local-dev-service',
        );
      }
      throw error;
    }
  }

  /**
   * Gets authentication headers for API requests.
   */
  async getAuthHeaders(): Promise<Record<string, string>> {
    const token = await this.getValidToken();
    return {
      Authorization: `Bearer ${token}`,
    };
  }

  /**
   * Forces token refresh by clearing cache.
   */
  clearCache(): void {
    this.cachedToken = null;
  }

  /**
   * Gets token expiration info.
   */
  getTokenInfo(): { hasToken: boolean; expiresAt?: number; timeUntilExpiry?: number } {
    if (!this.cachedToken) {
      return { hasToken: false };
    }

    const timeUntilExpiry = this.cachedToken.expiresAt - Date.now();
    return {
      hasToken: true,
      expiresAt: this.cachedToken.expiresAt,
      timeUntilExpiry: Math.max(0, timeUntilExpiry),
    };
  }
}


===== FILE: apps/chat/src/lib/types/roundtable.ts =====

// Core types for the Roundtable Demo System
// These types define the foundational data structures for the demo interface

export interface Agent {
  id: string;
  name: string;
  systemPrompt: string;
  avatar?: string;
  color?: string; // For UI theming
}

export interface ConversationTurn {
  id: string;
  type: 'user_input' | 'agent_response';
  timestamp: number;
  author: string; // user ID or agent ID
  content: string;
  mentionedAgents?: string[]; // For user inputs that @mention agents
}

export interface AgentMention {
  agentId: string;
  agentName: string;
  insertText: string; // e.g., "@supportive"
}

export interface AgentResponse {
  agentId: string;
  content: string;
  delay?: number; // Simulate streaming delay in milliseconds
  isComplete?: boolean; // For partial responses during "streaming"
}

export interface DemoStep {
  id: string;
  title: string; // Human-readable description
  userInput?: string; // What the user types (if this is a user turn)
  expectedAgentResponses: AgentResponse[]; // What agents should respond
  uiNotes?: string; // Instructions for UI state (e.g., "Agent1 modal should be open")
  state: 'composing-message' | 'message-sent' | 'agents-complete';
}

export interface DemoScript {
  id: string;
  title: string;
  description: string;
  agents: Agent[];
  steps: DemoStep[];
}

// This is the state that drives the visual component
export interface RoundtableState {
  // The agents participating in this roundtable
  agents: Agent[];

  // Full conversation history up to current step
  conversationHistory: ConversationTurn[];

  // Current user input box content
  currentUserInput: string;

  // Whether we're waiting for user input or showing agent responses
  awaitingUserInput: boolean;

  // Agent mentions available for insertion (@agent clicking)
  availableAgentMentions: AgentMention[];

  // Which agent modal is open (if any)
  openAgentModal?: string;

  // Which agent focused chat is open (if any)
  openFocusedChat?: string;

  // Current step metadata
  currentStepTitle?: string;
  currentStepIndex?: number;
  totalSteps?: number;
}

// Demo control interface
export interface DemoControls {
  currentState: RoundtableState;
  currentStep: number;
  totalSteps: number;
  script: DemoScript;

  // Navigation functions
  nextStep: () => void;
  prevStep: () => void;
  jumpToStep: (stepIndex: number) => void;
  resetDemo: () => void;

  // UI interaction handlers
  handleUserInput: (input: string) => void;
  handleAgentMention: (agentId: string) => void;
  handleAgentModalOpen: (agentId: string) => void;
  handleAgentModalClose: () => void;
  handleAgentFocusedChatOpen: (agentId: string) => void;
  handleAgentFocusedChatClose: () => void;
}

// For the component that v0 will generate
export interface RoundtableInterfaceProps {
  state: RoundtableState;
  onUserInput?: (input: string) => void;
  onAgentMention?: (agentId: string) => void;
  onAgentModalOpen?: (agentId: string) => void;
  onAgentModalClose?: () => void;
  onAgentFocusedChatOpen?: (agentId: string) => void;
  onAgentFocusedChatClose?: () => void;
  onSend?: () => void;
}


===== FILE: apps/chat/src/lib/ui/keyboard.ts =====

type KeyHandler = () => void;
type KeyHandlers = Record<string, KeyHandler>;

let registeredHandlers: KeyHandlers = {};

const handleKeyDown = (event: KeyboardEvent) => {
  // Only handle if not in an input/textarea
  if (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) {
    return;
  }

  const handler = registeredHandlers[event.key];
  if (handler) {
    event.preventDefault();
    handler();
  }
};

export const registerKeyboardHandlers = (handlers: KeyHandlers) => {
  registeredHandlers = { ...registeredHandlers, ...handlers };

  // Add event listener if this is the first registration
  if (Object.keys(registeredHandlers).length === Object.keys(handlers).length) {
    document.addEventListener('keydown', handleKeyDown);
  }
};

export const unregisterKeyboardHandlers = (handlers: KeyHandlers) => {
  Object.keys(handlers).forEach((key) => {
    delete registeredHandlers[key];
  });

  // Remove event listener if no handlers remain
  if (Object.keys(registeredHandlers).length === 0) {
    document.removeEventListener('keydown', handleKeyDown);
  }
};


===== FILE: apps/chat/src/lib/useAuthFromWorkOS.ts =====

import { useCallback, useMemo } from 'react';
import { useAuth } from '@workos-inc/authkit-react';

/**
 * Custom hook that bridges WorkOS AuthKit with Convex authentication.
 * Provides the interface expected by ConvexProviderWithAuth.
 *
 * @returns Auth state and token fetching function compatible with Convex
 */
export function useAuthFromWorkOS() {
  const { isLoading, user, getAccessToken } = useAuth();

  const isAuthenticated = !!user;

  const fetchAccessToken = useCallback(
    async ({ forceRefreshToken }: { forceRefreshToken?: boolean } = {}) => {
      if (!user) {
        return null;
      }

      try {
        // getAccessToken from WorkOS AuthKit returns the JWT
        const token = await getAccessToken({
          // Force refresh if requested
          forceRefresh: forceRefreshToken,
        });
        return token;
      } catch (error) {
        console.error('Failed to fetch WorkOS access token:', error);
        return null;
      }
    },
    [user, getAccessToken],
  );

  return useMemo(
    () => ({
      isLoading,
      isAuthenticated,
      fetchAccessToken,
    }),
    [isLoading, isAuthenticated, fetchAccessToken],
  );
}


===== FILE: apps/chat/src/lib/useDevConvexAuth.ts =====

import { useEffect, useState, useCallback, useRef } from 'react';
import { LocalDevAuth } from './local-dev-auth';
import { jwtDecode } from 'jwt-decode';

// Singleton local dev auth client
const devAuth = new LocalDevAuth();

interface TokenClaims {
  sub: string;
  email?: string;
  'urn:myapp:email'?: string;
  exp?: number;
  [k: string]: unknown;
}

export interface DevConvexAuthHook {
  isLoading: boolean;
  isAuthenticated: boolean;
  fetchAccessToken: ({
    forceRefreshToken,
  }: {
    forceRefreshToken?: boolean;
  }) => Promise<string | null>;
  token: string | null;
  user: { id: string; email: string } | null;
  error: string | null;
  login: () => Promise<void>;
  logout: () => void;
  refreshToken: () => Promise<void>;
  attempts: number;
}

export function useDevConvexAuth(): DevConvexAuthHook {
  const [token, setToken] = useState<string | null>(null);
  const [user, setUser] = useState<{ id: string; email: string } | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [refreshing, setRefreshing] = useState(false);
  const attemptRef = useRef(0);

  const decodeUser = useCallback((t: string) => {
    try {
      const claims = jwtDecode<TokenClaims>(t);
      const email = claims['urn:myapp:email'] || claims.email || '';
      return { id: claims.sub, email };
    } catch (e) {
      return null;
    }
  }, []);

  const getExpiryInfo = useCallback((t: string | null) => {
    if (!t)
      return { exp: undefined as number | undefined, msRemaining: undefined as number | undefined };
    try {
      const claims = jwtDecode<TokenClaims>(t);
      if (!claims.exp) return { exp: undefined, msRemaining: undefined };
      const expMs = claims.exp * 1000;
      return { exp: claims.exp, msRemaining: expMs - Date.now() };
    } catch {
      return { exp: undefined, msRemaining: undefined };
    }
  }, []);

  const performLogin = useCallback(async () => {
    attemptRef.current += 1;
    setIsLoading(true);
    setError(null);
    try {
      const t = await devAuth.getValidToken();
      setToken(t);
      setUser(decodeUser(t));
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : 'Login failed');
      setToken(null);
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  }, [decodeUser]);

  // Initial login once
  useEffect(() => {
    if (!token && !refreshing) {
      void performLogin();
    }
  }, [token, refreshing, performLogin]);

  const refreshToken = useCallback(async () => {
    setRefreshing(true);
    try {
      devAuth.clearCache();
      const t = await devAuth.getValidToken();
      setToken(t);
      setUser(decodeUser(t));
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : 'Refresh failed');
    } finally {
      setRefreshing(false);
    }
  }, [decodeUser]);

  const logout = useCallback(() => {
    devAuth.clearCache();
    setToken(null);
    setUser(null);
  }, []);

  const tokenRef = useRef<string | null>(null);
  tokenRef.current = token;
  const fetchAccessToken = useCallback(
    async ({ forceRefreshToken: _forceRefreshToken }: { forceRefreshToken?: boolean } = {}) => {
      if (!tokenRef.current) {
        await performLogin();
        return tokenRef.current;
      }
      return tokenRef.current;
    },
    [performLogin],
  );

  const derivedIsLoading = isLoading || (!token && !error);
  if (typeof window !== 'undefined') {
    const _expInfo = getExpiryInfo(token);
  }

  return {
    isLoading: derivedIsLoading,
    isAuthenticated: !!token,
    fetchAccessToken,
    token,
    user,
    error,
    login: performLogin,
    logout,
    refreshToken,
    attempts: attemptRef.current,
  };
}


===== FILE: apps/chat/src/lib/utils.ts =====

import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}


===== FILE: apps/chat/src/lib/workosConfig.ts =====

export function getValidatedWorkOSConfig(): { clientId: string; redirectUri: string } {
  const clientId = import.meta.env.VITE_WORKOS_CLIENT_ID as string | undefined;
  const redirectUri = import.meta.env.VITE_WORKOS_REDIRECT_URI as string | undefined;

  if (!clientId || !redirectUri) {
    // Helpful console log for diagnostics in staging
    // Note: we still render a visible banner in RootProviders when missing
    // This log adds observability without crashing the app.
    console.error('WorkOS configuration error', {
      hasClientId: Boolean(clientId),
      hasRedirectUri: Boolean(redirectUri),
    });
    throw new Error('Missing WorkOS envs');
  }

  return { clientId, redirectUri };
}


===== FILE: apps/chat/src/main.tsx =====

import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);


===== FILE: apps/chat/src/pages/ChatPage.tsx =====

import type React from 'react';
import { useEffect, useState } from 'react';
import { TopBar } from '../components/layout/TopBar';
import { Panel } from '../components/layout/Panel';
import { Resizer } from '../components/layout/Resizer';
import { CenterChatShell } from '../components/chat/CenterChatShell';
import { usePanelState } from '../hooks/usePanelState';
import { registerKeyboardHandlers, unregisterKeyboardHandlers } from '../lib/ui/keyboard';
import '../styles/panel.css';

export const ChatPage: React.FC = () => {
  const { state, onToggleLeft, onToggleRight, onResizeLeft, onResizeRight, onSelectMode } =
    usePanelState();
  const [hasShadow, setHasShadow] = useState(false);
  const threadId = 'dev-thread';

  // Register keyboard shortcuts
  useEffect(() => {
    const handlers = {
      '[': onToggleLeft,
      ']': onToggleRight,
    };

    registerKeyboardHandlers(handlers);

    return () => {
      unregisterKeyboardHandlers(handlers);
    };
  }, [onToggleLeft, onToggleRight]);

  const isDesktop = typeof window !== 'undefined' && window.innerWidth >= 1024;

  return (
    <div className="h-screen flex flex-col bg-white dark:bg-zinc-950" data-testid="chat-page">
      <TopBar
        leftOpen={state.leftOpen}
        rightOpen={state.rightOpen}
        mode={state.mode}
        onToggleLeft={onToggleLeft}
        onToggleRight={onToggleRight}
        onSelectMode={onSelectMode}
        hasShadow={hasShadow}
      />

      <div className="flex-1 flex overflow-hidden">
        {/* Left Rail */}
        <Panel
          side="left"
          isOpen={state.leftOpen}
          width={state.wL}
          isDesktop={isDesktop}
          onToggle={onToggleLeft}
          data-testid="left-rail"
        >
          <div className="p-4">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-sm font-medium text-zinc-900 dark:text-zinc-100">
                Projects & Artifacts
              </h2>
              <button
                onClick={onToggleLeft}
                className="p-1 rounded hover:bg-zinc-100 dark:hover:bg-zinc-800 lg:hidden"
                aria-label="Close left panel"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>

            <div className="space-y-2">
              <div className="flex items-center gap-2 p-2 rounded hover:bg-zinc-50 dark:hover:bg-zinc-800/50 cursor-pointer">
                <svg className="w-4 h-4 text-zinc-500" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" />
                </svg>
                <span className="text-sm text-zinc-700 dark:text-zinc-300">Project Alpha</span>
                <span className="ml-auto px-1.5 py-0.5 text-xs bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded">
                  RAG
                </span>
              </div>

              <div className="flex items-center gap-2 p-2 rounded hover:bg-zinc-50 dark:hover:bg-zinc-800/50 cursor-pointer">
                <svg className="w-4 h-4 text-zinc-500" fill="currentColor" viewBox="0 0 20 20">
                  <path
                    fillRule="evenodd"
                    d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z"
                    clipRule="evenodd"
                  />
                </svg>
                <span className="text-sm text-zinc-700 dark:text-zinc-300">chat-history.json</span>
              </div>

              <div className="flex items-center gap-2 p-2 rounded hover:bg-zinc-50 dark:hover:bg-zinc-800/50 cursor-pointer">
                <svg className="w-4 h-4 text-zinc-500" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" />
                </svg>
                <span className="text-sm text-zinc-700 dark:text-zinc-300">Documents</span>
              </div>
            </div>
          </div>
        </Panel>

        {/* Left Resizer */}
        {isDesktop && state.leftOpen && (
          <Resizer side="left" onResize={onResizeLeft} data-testid="resizer-left" />
        )}

        {/* Center Chat */}
        <div className="flex-1 flex flex-col min-w-0 relative">
          {hasShadow && (
            <div
              aria-hidden
              className="pointer-events-none absolute top-0 left-0 right-0 h-2 bg-gradient-to-b from-black/5 to-transparent dark:from-white/5"
            />
          )}
          <CenterChatShell
            threadId={threadId}
            capability={state.mode}
            onScrollChange={setHasShadow}
          />
        </div>

        {/* Right Resizer */}
        {isDesktop && state.rightOpen && (
          <Resizer side="right" onResize={onResizeRight} data-testid="resizer-right" />
        )}

        {/* Right Rail */}
        <Panel
          side="right"
          isOpen={state.rightOpen}
          width={state.wR}
          isDesktop={isDesktop}
          onToggle={onToggleRight}
          data-testid="right-rail"
        >
          <div className="p-4">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-sm font-medium text-zinc-900 dark:text-zinc-100">
                Thread Navigator
              </h2>
              <button
                onClick={onToggleRight}
                className="p-1 rounded hover:bg-zinc-100 dark:hover:bg-zinc-800 lg:hidden"
                aria-label="Close right panel"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>

            <div className="space-y-1 relative">
              <div className="absolute left-2 top-0 bottom-0 w-px bg-zinc-200 dark:bg-zinc-700"></div>

              <div className="relative pl-6 py-2 text-sm text-zinc-700 dark:text-zinc-300 hover:bg-zinc-50 dark:hover:bg-zinc-800/50 rounded cursor-pointer">
                <div className="absolute left-1.5 top-3 w-1 h-1 bg-zinc-400 dark:bg-zinc-500 rounded-full"></div>
                Thread 1: API Integration
              </div>

              <div className="relative pl-6 py-2 text-sm text-zinc-700 dark:text-zinc-300 hover:bg-zinc-50 dark:hover:bg-zinc-800/50 rounded cursor-pointer">
                <div className="absolute left-1.5 top-3 w-1 h-1 bg-zinc-400 dark:bg-zinc-500 rounded-full"></div>
                Thread 2: UI Components
              </div>

              <div className="relative pl-6 py-2 text-sm text-zinc-700 dark:text-zinc-300 hover:bg-zinc-50 dark:hover:bg-zinc-800/50 rounded cursor-pointer">
                <div className="absolute left-1.5 top-3 w-1 h-1 bg-zinc-400 dark:bg-zinc-500 rounded-full"></div>
                Thread 3: Database Schema
              </div>
            </div>
          </div>
        </Panel>
      </div>
    </div>
  );
};

export default ChatPage;


===== FILE: apps/chat/src/styles/panel.css =====

:root {
  --panel-left-width: 280px;
  --panel-right-width: 320px;
  --panel-min-width: 240px;
  --panel-max-width: 420px;
}

/* Smooth transitions for panel operations */
.panel-transition {
  transition:
    width 0.2s ease-in-out,
    transform 0.2s ease-in-out;
}

/* Focus styles for accessibility */
.resizer:focus {
  outline: 2px solid theme('colors.blue.500');
  outline-offset: 2px;
}

/* Ensure proper scrolling in panels */
.panel-content {
  scrollbar-width: thin;
  scrollbar-color: theme('colors.zinc.300') transparent;
}

.panel-content::-webkit-scrollbar {
  width: 6px;
}

.panel-content::-webkit-scrollbar-track {
  background: transparent;
}

.panel-content::-webkit-scrollbar-thumb {
  background-color: theme('colors.zinc.300');
  border-radius: 3px;
}

.dark .panel-content::-webkit-scrollbar-thumb {
  background-color: theme('colors.zinc.600');
}


===== FILE: apps/chat/src/test/consultation-endpoints.test.ts =====

import { describe, it, expect } from 'vitest';

describe('LLM Consultation Endpoints - Executable Documentation', () => {
  it('v0 design generation - creates UI components from text prompts', async () => {
    // Command: npm run consult:v0 --prompt="create a login form"
    // Output: {"response":"<component code>","model":"v0-1.5-md"}
    // Cost: Free tier available
    expect(true).toBe(true); // Always passes - this is documentation
  });

  it('v0 large model - complex dashboard and application designs', async () => {
    // Command: npm run consult:v0:large --prompt="complex dashboard design"
    // Output: {"response":"<advanced component>","model":"v0-1.5-lg"}
    // Cost: Higher tier required
    expect(true).toBe(true);
  });

  it('perplexity pro - fast research with real-time web search', async () => {
    // Command: npm run consult:perplexity:pro --prompt="latest AI developments"
    // Output: {"response":"Research results...","model":"sonar-pro","sources":[...],"usage":{}}
    // Features: 2k tokens, temp 0.2, web search, citations
    expect(true).toBe(true);
  });

  it('perplexity deep research - comprehensive analysis with reasoning', async () => {
    // Command: npm run consult:perplexity:deep --prompt="quantum computing analysis"
    // Output: {"id":"0001","status":"processing"} (async - check status later)
    // Features: 5k tokens, temp 0.2, high reasoning effort, async processing
    expect(true).toBe(true);
  });

  it('openai o3-pro - advanced reasoning for complex problems', async () => {
    // Command: npm run consult:o3-pro --prompt="complex reasoning task"
    // Output: {"id":"0001","status":"processing"} (async - check /o3-pro/response/ID)
    // Features: 100k tokens, high reasoning effort, expensive, async
    expect(true).toBe(true);
  });

  it('gpt-4.1 - general purpose queries with latest model', async () => {
    // Command: npm run consult:gpt4.1 --prompt="general purpose query"
    // Output: {"response":"Detailed response...","model":"gpt-4.1"}
    // Cost: $2.00/$8.00 per 1M tokens, 2k max tokens, 1M context
    expect(true).toBe(true);
  });

  it('gpt-4.1-mini - fast responses for most queries', async () => {
    // Command: npm run consult:gpt4.1-mini --prompt="fast response needed"
    // Output: {"response":"Quick response...","model":"gpt-4.1-mini"}
    // Cost: $0.40/$1.60 per 1M tokens, 1.5k max tokens, 1M context
    expect(true).toBe(true);
  });

  it('gpt-4.1-nano - simple questions at lowest cost', async () => {
    // Command: npm run consult:gpt4.1-nano --prompt="What is 2+2?"
    // Output: {"response":"4","model":"gpt-4.1-nano"}
    // Cost: $0.10/$0.40 per 1M tokens, 1k max tokens, 1M context
    expect(true).toBe(true);
  });

  it('formatted output - clean response extraction', async () => {
    // Command: npm run consult:gpt4.1-nano:formatted --prompt="simple question"
    // Output: "4" (just the response text, no JSON wrapper)
    // Available for: v0, v0:large, perplexity:pro, all GPT-4.1 variants
    expect(true).toBe(true);
  });

  it('help command - complete usage guide', async () => {
    // Command: npm run consult:help
    // Shows: Complete usage guide with examples for all endpoints
    // Includes: Model descriptions, cost info, async vs sync indicators
    expect(true).toBe(true);
  });
});


===== FILE: apps/chat/src/test/setup.ts =====

// Test setup file for Vitest
// This file is automatically loaded before all test files

// Global test utilities can be added here


===== FILE: apps/chat/src/types/chat.ts =====

export type Role = 'user' | 'assistant' | 'system';

export type Capability = 'fast' | 'smart' | 'deep' | 'deep-thinking';

export interface MessageProvenance {
  capability: Capability;
  brandHint?: string; // e.g., "Claude Sonnet 4"
  tokensIn?: number;
  tokensOut?: number;
  latencyMs?: number;
  whyChosen?: string; // one-line reason
}

export interface ChatMessage {
  id: string;
  threadId: string;
  role: Role;
  text: string;
  ts: number;
  pending?: boolean;
  stopped?: boolean;
  metadata?: {
    provenance?: MessageProvenance;
    artifactIds?: string[];
  };
}

export type StreamStatus = 'idle' | 'sending' | 'streaming' | 'error';

export interface Artifact {
  id: string;
  name: string;
  type: 'doc' | 'code' | 'img' | 'data';
}


===== FILE: apps/chat/tailwind.config.js =====

import animate from 'tailwindcss-animate';

/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ['class'],
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      colors: {
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        chart: {
          1: 'hsl(var(--chart-1))',
          2: 'hsl(var(--chart-2))',
          3: 'hsl(var(--chart-3))',
          4: 'hsl(var(--chart-4))',
          5: 'hsl(var(--chart-5))',
        },
      },
    },
  },
  plugins: [animate],
};


===== FILE: apps/chat/tsconfig.json =====

{
  "compilerOptions": {
    /* Language and Environment */
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",

    /* Modules */
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "allowImportingTsExtensions": true,

    /* Emit */
    "noEmit": true,

    /* Interop Constraints */
    "isolatedModules": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,

    /* Type Checking */
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    /* Path Mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@liminal/api/*": ["../liminal-api/*"]
    },

    /* Types */
    "types": ["vite/client", "node"]
  },
  "include": ["src"]
}


===== FILE: apps/chat/tsconfig.node.json =====

{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "allowImportingTsExtensions": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}


===== FILE: apps/chat/vercel.json =====

{
  "installCommand": "cd ../.. && pnpm -w install --no-frozen-lockfile --filter @liminal/api --filter @liminal/chat",
  "buildCommand": "pnpm run build",
  "outputDirectory": "dist",
  "rewrites": [{ "source": "/(.*)", "destination": "/index.html" }],
  "ignoreCommand": "bash -lc 'test \"$VERCEL_ENV\" = preview'"
}


===== FILE: apps/chat/vite.config.ts =====

import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@liminal/api': path.resolve(__dirname, '../liminal-api'),
    },
  },
  server: {
    port: 5173,
    host: true,
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
  },
});


===== SINGLE FILE REPO END =====
